<alloy builddate="2021-11-03T15:25:43.736Z">

<instance bitwidth="4" maxseq="4" mintrace="1" maxtrace="25" command="Check irp_transition for 1..25 steps, 1 Volatile, 7 PMObj" filename="/home/hayley/fs-modeling/persistence_checks.als" tracelength="6" backloop="5">

<sig label="seq/Int" ID="0" parentID="1" builtin="yes">
</sig>

<sig label="Int" ID="1" parentID="2" builtin="yes">
</sig>

<sig label="String" ID="3" parentID="2" builtin="yes">
</sig>

<sig label="defs/Dentry" ID="4" parentID="5" some="yes">
   <atom label="defs/Dentry$0"/>
   <atom label="defs/Dentry$1"/>
</sig>

<field label="inode" ID="6" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/FileInode$1"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/FileInode$0"/> </tuple>
   <types> <type ID="4"/> <type ID="7"/> </types>
</field>

<field label="name_qw_set" ID="8" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="2"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="2"/> </tuple>
   <types> <type ID="4"/> <type ID="1"/> </types>
</field>

<field label="rename_pointer" ID="9" parentID="4" var="yes">
   <types> <type ID="4"/> <type ID="4"/> </types>
</field>

<sig label="defs/Root" ID="10" parentID="11" one="yes">
   <atom label="defs/Root$0"/>
</sig>

<sig label="defs/DirInode" ID="11" parentID="7">
</sig>

<sig label="defs/FileInode" ID="12" parentID="7">
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
</sig>

<sig label="defs/Inode" ID="7" parentID="5" abstract="yes">
</sig>

<field label="link_count" ID="13" parentID="7" var="yes">
   <tuple> <atom label="defs/Root$0"/> <atom label="2"/> </tuple>
   <tuple> <atom label="defs/FileInode$0"/> <atom label="1"/> </tuple>
   <tuple> <atom label="defs/FileInode$1"/> <atom label="1"/> </tuple>
   <types> <type ID="7"/> <type ID="1"/> </types>
</field>

<sig label="defs/DataPageHeader" ID="14" parentID="15">
</sig>

<sig label="defs/DirPageHeader" ID="16" parentID="15">
   <atom label="defs/DirPageHeader$0"/>
   <atom label="defs/DirPageHeader$1"/>
</sig>

<field label="parent_ino" ID="17" parentID="16" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="16"/> <type ID="7"/> </types>
</field>

<field label="dentries" ID="18" parentID="16" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Dentry$1"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Dentry$0"/> </tuple>
   <types> <type ID="16"/> <type ID="4"/> </types>
</field>

<sig label="defs/PageHeader" ID="15" parentID="5" abstract="yes">
</sig>

<field label="inode" ID="19" parentID="15" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="15"/> <type ID="7"/> </types>
</field>

<sig label="defs/PMObj" ID="5" parentID="2" abstract="yes">
</sig>

<field label="typestate" ID="20" parentID="5" var="yes">
   <types> <type ID="5"/> <type ID="21"/> </types>
</field>

<sig label="defs/Start" ID="22" parentID="21" one="yes">
   <atom label="defs/Start$0"/>
</sig>

<sig label="defs/Free" ID="23" parentID="21" one="yes">
   <atom label="defs/Free$0"/>
</sig>

<sig label="defs/AllocStarted" ID="24" parentID="21" one="yes">
   <atom label="defs/AllocStarted$0"/>
</sig>

<sig label="defs/Alloc" ID="25" parentID="21" one="yes">
   <atom label="defs/Alloc$0"/>
</sig>

<sig label="defs/Init" ID="26" parentID="21" one="yes">
   <atom label="defs/Init$0"/>
</sig>

<sig label="defs/Complete" ID="27" parentID="21" one="yes">
   <atom label="defs/Complete$0"/>
</sig>

<sig label="defs/IncLink" ID="28" parentID="21" one="yes">
   <atom label="defs/IncLink$0"/>
</sig>

<sig label="defs/SetRenamePointer" ID="29" parentID="21" one="yes">
   <atom label="defs/SetRenamePointer$0"/>
</sig>

<sig label="defs/InitRenamePointer" ID="30" parentID="21" one="yes">
   <atom label="defs/InitRenamePointer$0"/>
</sig>

<sig label="defs/ClearRenamePointer" ID="31" parentID="21" one="yes">
   <atom label="defs/ClearRenamePointer$0"/>
</sig>

<sig label="defs/Renaming" ID="32" parentID="21" one="yes">
   <atom label="defs/Renaming$0"/>
</sig>

<sig label="defs/Renamed" ID="33" parentID="21" one="yes">
   <atom label="defs/Renamed$0"/>
</sig>

<sig label="defs/ClearIno" ID="34" parentID="21" one="yes">
   <atom label="defs/ClearIno$0"/>
</sig>

<sig label="defs/DeallocStart" ID="35" parentID="21" one="yes">
   <atom label="defs/DeallocStart$0"/>
</sig>

<sig label="defs/Dealloc" ID="36" parentID="21" one="yes">
   <atom label="defs/Dealloc$0"/>
</sig>

<sig label="defs/OpTypestate" ID="21" parentID="2" abstract="yes">
</sig>

<sig label="defs/Volatile" ID="37" parentID="2" one="yes">
   <atom label="defs/Volatile$0"/>
</sig>

<field label="parent" ID="38" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/FileInode$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/FileInode$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="37"/> <type ID="7"/> <type ID="11"/> </types>
</field>

<field label="children" ID="39" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/FileInode$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/FileInode$1"/> </tuple>
   <types> <type ID="37"/> <type ID="11"/> <type ID="7"/> </types>
</field>

<field label="owns" ID="40" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$1"/> </tuple>
   <types> <type ID="37"/> <type ID="7"/> <type ID="15"/> </types>
</field>

<sig label="univ" ID="2" builtin="yes" var="yes">
</sig>

<sig label="defs/InodeValues" ID="41" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="7"/>
</sig>

<sig label="defs/InodeSet" ID="42" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/LcSet" ID="43" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/MetadataSet" ID="44" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/TypeSet" ID="45" var="yes">
   <type ID="15"/>
</sig>

<sig label="defs/Dirty" ID="46" var="yes">
   <type ID="5"/>
</sig>

<sig label="defs/InFlight" ID="47" var="yes">
   <type ID="5"/>
</sig>

<sig label="defs/Clean" ID="48" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <atom label="defs/DirPageHeader$0"/>
   <atom label="defs/DirPageHeader$1"/>
   <atom label="defs/Dentry$0"/>
   <atom label="defs/Dentry$1"/>
   <type ID="5"/>
</sig>

<skolem label="$irp_transition_p" ID="49">
   <tuple> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$0"/> </tuple>
   <types> <type ID="11"/> <type ID="16"/> </types>
</skolem>

<skolem label="$irp_transition_dst" ID="50">
   <tuple> <atom label="defs/Dentry$1"/> </tuple>
   <types> <type ID="4"/> </types>
</skolem>

</instance>
<instance bitwidth="4" maxseq="4" mintrace="1" maxtrace="25" command="Check irp_transition for 1..25 steps, 1 Volatile, 7 PMObj" filename="/home/hayley/fs-modeling/persistence_checks.als" tracelength="6" backloop="5">

<sig label="seq/Int" ID="0" parentID="1" builtin="yes">
</sig>

<sig label="Int" ID="1" parentID="2" builtin="yes">
</sig>

<sig label="String" ID="3" parentID="2" builtin="yes">
</sig>

<sig label="defs/Dentry" ID="4" parentID="5" some="yes">
   <atom label="defs/Dentry$0"/>
   <atom label="defs/Dentry$1"/>
</sig>

<field label="inode" ID="6" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/FileInode$1"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/FileInode$0"/> </tuple>
   <types> <type ID="4"/> <type ID="7"/> </types>
</field>

<field label="name_qw_set" ID="8" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="2"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="2"/> </tuple>
   <types> <type ID="4"/> <type ID="1"/> </types>
</field>

<field label="rename_pointer" ID="9" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/Dentry$1"/> </tuple>
   <types> <type ID="4"/> <type ID="4"/> </types>
</field>

<sig label="defs/Root" ID="10" parentID="11" one="yes">
   <atom label="defs/Root$0"/>
</sig>

<sig label="defs/DirInode" ID="11" parentID="7">
</sig>

<sig label="defs/FileInode" ID="12" parentID="7">
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
</sig>

<sig label="defs/Inode" ID="7" parentID="5" abstract="yes">
</sig>

<field label="link_count" ID="13" parentID="7" var="yes">
   <tuple> <atom label="defs/Root$0"/> <atom label="2"/> </tuple>
   <tuple> <atom label="defs/FileInode$0"/> <atom label="1"/> </tuple>
   <tuple> <atom label="defs/FileInode$1"/> <atom label="1"/> </tuple>
   <types> <type ID="7"/> <type ID="1"/> </types>
</field>

<sig label="defs/DataPageHeader" ID="14" parentID="15">
</sig>

<sig label="defs/DirPageHeader" ID="16" parentID="15">
   <atom label="defs/DirPageHeader$0"/>
   <atom label="defs/DirPageHeader$1"/>
</sig>

<field label="parent_ino" ID="17" parentID="16" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="16"/> <type ID="7"/> </types>
</field>

<field label="dentries" ID="18" parentID="16" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Dentry$1"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Dentry$0"/> </tuple>
   <types> <type ID="16"/> <type ID="4"/> </types>
</field>

<sig label="defs/PageHeader" ID="15" parentID="5" abstract="yes">
</sig>

<field label="inode" ID="19" parentID="15" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="15"/> <type ID="7"/> </types>
</field>

<sig label="defs/PMObj" ID="5" parentID="2" abstract="yes">
</sig>

<field label="typestate" ID="20" parentID="5" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/SetRenamePointer$0"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/Renaming$0"/> </tuple>
   <types> <type ID="5"/> <type ID="21"/> </types>
</field>

<sig label="defs/Start" ID="22" parentID="21" one="yes">
   <atom label="defs/Start$0"/>
</sig>

<sig label="defs/Free" ID="23" parentID="21" one="yes">
   <atom label="defs/Free$0"/>
</sig>

<sig label="defs/AllocStarted" ID="24" parentID="21" one="yes">
   <atom label="defs/AllocStarted$0"/>
</sig>

<sig label="defs/Alloc" ID="25" parentID="21" one="yes">
   <atom label="defs/Alloc$0"/>
</sig>

<sig label="defs/Init" ID="26" parentID="21" one="yes">
   <atom label="defs/Init$0"/>
</sig>

<sig label="defs/Complete" ID="27" parentID="21" one="yes">
   <atom label="defs/Complete$0"/>
</sig>

<sig label="defs/IncLink" ID="28" parentID="21" one="yes">
   <atom label="defs/IncLink$0"/>
</sig>

<sig label="defs/SetRenamePointer" ID="29" parentID="21" one="yes">
   <atom label="defs/SetRenamePointer$0"/>
</sig>

<sig label="defs/InitRenamePointer" ID="30" parentID="21" one="yes">
   <atom label="defs/InitRenamePointer$0"/>
</sig>

<sig label="defs/ClearRenamePointer" ID="31" parentID="21" one="yes">
   <atom label="defs/ClearRenamePointer$0"/>
</sig>

<sig label="defs/Renaming" ID="32" parentID="21" one="yes">
   <atom label="defs/Renaming$0"/>
</sig>

<sig label="defs/Renamed" ID="33" parentID="21" one="yes">
   <atom label="defs/Renamed$0"/>
</sig>

<sig label="defs/ClearIno" ID="34" parentID="21" one="yes">
   <atom label="defs/ClearIno$0"/>
</sig>

<sig label="defs/DeallocStart" ID="35" parentID="21" one="yes">
   <atom label="defs/DeallocStart$0"/>
</sig>

<sig label="defs/Dealloc" ID="36" parentID="21" one="yes">
   <atom label="defs/Dealloc$0"/>
</sig>

<sig label="defs/OpTypestate" ID="21" parentID="2" abstract="yes">
</sig>

<sig label="defs/Volatile" ID="37" parentID="2" one="yes">
   <atom label="defs/Volatile$0"/>
</sig>

<field label="parent" ID="38" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/FileInode$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/FileInode$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="37"/> <type ID="7"/> <type ID="11"/> </types>
</field>

<field label="children" ID="39" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/FileInode$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/FileInode$1"/> </tuple>
   <types> <type ID="37"/> <type ID="11"/> <type ID="7"/> </types>
</field>

<field label="owns" ID="40" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$1"/> </tuple>
   <types> <type ID="37"/> <type ID="7"/> <type ID="15"/> </types>
</field>

<sig label="univ" ID="2" builtin="yes" var="yes">
</sig>

<sig label="defs/InodeValues" ID="41" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="7"/>
</sig>

<sig label="defs/InodeSet" ID="42" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/LcSet" ID="43" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/MetadataSet" ID="44" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/TypeSet" ID="45" var="yes">
   <type ID="15"/>
</sig>

<sig label="defs/Dirty" ID="46" var="yes">
   <atom label="defs/Dentry$0"/>
   <type ID="5"/>
</sig>

<sig label="defs/InFlight" ID="47" var="yes">
   <type ID="5"/>
</sig>

<sig label="defs/Clean" ID="48" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <atom label="defs/DirPageHeader$0"/>
   <atom label="defs/DirPageHeader$1"/>
   <atom label="defs/Dentry$1"/>
   <type ID="5"/>
</sig>

<skolem label="$irp_transition_p" ID="49">
   <tuple> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$0"/> </tuple>
   <types> <type ID="11"/> <type ID="16"/> </types>
</skolem>

<skolem label="$irp_transition_dst" ID="50">
   <tuple> <atom label="defs/Dentry$1"/> </tuple>
   <types> <type ID="4"/> </types>
</skolem>

</instance>
<instance bitwidth="4" maxseq="4" mintrace="1" maxtrace="25" command="Check irp_transition for 1..25 steps, 1 Volatile, 7 PMObj" filename="/home/hayley/fs-modeling/persistence_checks.als" tracelength="6" backloop="5">

<sig label="seq/Int" ID="0" parentID="1" builtin="yes">
</sig>

<sig label="Int" ID="1" parentID="2" builtin="yes">
</sig>

<sig label="String" ID="3" parentID="2" builtin="yes">
</sig>

<sig label="defs/Dentry" ID="4" parentID="5" some="yes">
   <atom label="defs/Dentry$0"/>
   <atom label="defs/Dentry$1"/>
</sig>

<field label="inode" ID="6" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/FileInode$1"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/FileInode$0"/> </tuple>
   <types> <type ID="4"/> <type ID="7"/> </types>
</field>

<field label="name_qw_set" ID="8" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="2"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="2"/> </tuple>
   <types> <type ID="4"/> <type ID="1"/> </types>
</field>

<field label="rename_pointer" ID="9" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/Dentry$1"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/Dentry$0"/> </tuple>
   <types> <type ID="4"/> <type ID="4"/> </types>
</field>

<sig label="defs/Root" ID="10" parentID="11" one="yes">
   <atom label="defs/Root$0"/>
</sig>

<sig label="defs/DirInode" ID="11" parentID="7">
</sig>

<sig label="defs/FileInode" ID="12" parentID="7">
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
</sig>

<sig label="defs/Inode" ID="7" parentID="5" abstract="yes">
</sig>

<field label="link_count" ID="13" parentID="7" var="yes">
   <tuple> <atom label="defs/Root$0"/> <atom label="2"/> </tuple>
   <tuple> <atom label="defs/FileInode$0"/> <atom label="1"/> </tuple>
   <tuple> <atom label="defs/FileInode$1"/> <atom label="1"/> </tuple>
   <types> <type ID="7"/> <type ID="1"/> </types>
</field>

<sig label="defs/DataPageHeader" ID="14" parentID="15">
</sig>

<sig label="defs/DirPageHeader" ID="16" parentID="15">
   <atom label="defs/DirPageHeader$0"/>
   <atom label="defs/DirPageHeader$1"/>
</sig>

<field label="parent_ino" ID="17" parentID="16" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="16"/> <type ID="7"/> </types>
</field>

<field label="dentries" ID="18" parentID="16" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Dentry$1"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Dentry$0"/> </tuple>
   <types> <type ID="16"/> <type ID="4"/> </types>
</field>

<sig label="defs/PageHeader" ID="15" parentID="5" abstract="yes">
</sig>

<field label="inode" ID="19" parentID="15" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="15"/> <type ID="7"/> </types>
</field>

<sig label="defs/PMObj" ID="5" parentID="2" abstract="yes">
</sig>

<field label="typestate" ID="20" parentID="5" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/SetRenamePointer$0"/> </tuple>
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/Renaming$0"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/SetRenamePointer$0"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/Renaming$0"/> </tuple>
   <types> <type ID="5"/> <type ID="21"/> </types>
</field>

<sig label="defs/Start" ID="22" parentID="21" one="yes">
   <atom label="defs/Start$0"/>
</sig>

<sig label="defs/Free" ID="23" parentID="21" one="yes">
   <atom label="defs/Free$0"/>
</sig>

<sig label="defs/AllocStarted" ID="24" parentID="21" one="yes">
   <atom label="defs/AllocStarted$0"/>
</sig>

<sig label="defs/Alloc" ID="25" parentID="21" one="yes">
   <atom label="defs/Alloc$0"/>
</sig>

<sig label="defs/Init" ID="26" parentID="21" one="yes">
   <atom label="defs/Init$0"/>
</sig>

<sig label="defs/Complete" ID="27" parentID="21" one="yes">
   <atom label="defs/Complete$0"/>
</sig>

<sig label="defs/IncLink" ID="28" parentID="21" one="yes">
   <atom label="defs/IncLink$0"/>
</sig>

<sig label="defs/SetRenamePointer" ID="29" parentID="21" one="yes">
   <atom label="defs/SetRenamePointer$0"/>
</sig>

<sig label="defs/InitRenamePointer" ID="30" parentID="21" one="yes">
   <atom label="defs/InitRenamePointer$0"/>
</sig>

<sig label="defs/ClearRenamePointer" ID="31" parentID="21" one="yes">
   <atom label="defs/ClearRenamePointer$0"/>
</sig>

<sig label="defs/Renaming" ID="32" parentID="21" one="yes">
   <atom label="defs/Renaming$0"/>
</sig>

<sig label="defs/Renamed" ID="33" parentID="21" one="yes">
   <atom label="defs/Renamed$0"/>
</sig>

<sig label="defs/ClearIno" ID="34" parentID="21" one="yes">
   <atom label="defs/ClearIno$0"/>
</sig>

<sig label="defs/DeallocStart" ID="35" parentID="21" one="yes">
   <atom label="defs/DeallocStart$0"/>
</sig>

<sig label="defs/Dealloc" ID="36" parentID="21" one="yes">
   <atom label="defs/Dealloc$0"/>
</sig>

<sig label="defs/OpTypestate" ID="21" parentID="2" abstract="yes">
</sig>

<sig label="defs/Volatile" ID="37" parentID="2" one="yes">
   <atom label="defs/Volatile$0"/>
</sig>

<field label="parent" ID="38" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/FileInode$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/FileInode$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="37"/> <type ID="7"/> <type ID="11"/> </types>
</field>

<field label="children" ID="39" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/FileInode$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/FileInode$1"/> </tuple>
   <types> <type ID="37"/> <type ID="11"/> <type ID="7"/> </types>
</field>

<field label="owns" ID="40" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$1"/> </tuple>
   <types> <type ID="37"/> <type ID="7"/> <type ID="15"/> </types>
</field>

<sig label="univ" ID="2" builtin="yes" var="yes">
</sig>

<sig label="defs/InodeValues" ID="41" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="7"/>
</sig>

<sig label="defs/InodeSet" ID="42" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/LcSet" ID="43" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/MetadataSet" ID="44" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/TypeSet" ID="45" var="yes">
   <type ID="15"/>
</sig>

<sig label="defs/Dirty" ID="46" var="yes">
   <atom label="defs/Dentry$0"/>
   <atom label="defs/Dentry$1"/>
   <type ID="5"/>
</sig>

<sig label="defs/InFlight" ID="47" var="yes">
   <type ID="5"/>
</sig>

<sig label="defs/Clean" ID="48" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <atom label="defs/DirPageHeader$0"/>
   <atom label="defs/DirPageHeader$1"/>
   <type ID="5"/>
</sig>

<skolem label="$irp_transition_p" ID="49">
   <tuple> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$0"/> </tuple>
   <types> <type ID="11"/> <type ID="16"/> </types>
</skolem>

<skolem label="$irp_transition_dst" ID="50">
   <tuple> <atom label="defs/Dentry$1"/> </tuple>
   <types> <type ID="4"/> </types>
</skolem>

</instance>
<instance bitwidth="4" maxseq="4" mintrace="1" maxtrace="25" command="Check irp_transition for 1..25 steps, 1 Volatile, 7 PMObj" filename="/home/hayley/fs-modeling/persistence_checks.als" tracelength="6" backloop="5">

<sig label="seq/Int" ID="0" parentID="1" builtin="yes">
</sig>

<sig label="Int" ID="1" parentID="2" builtin="yes">
</sig>

<sig label="String" ID="3" parentID="2" builtin="yes">
</sig>

<sig label="defs/Dentry" ID="4" parentID="5" some="yes">
   <atom label="defs/Dentry$0"/>
   <atom label="defs/Dentry$1"/>
</sig>

<field label="inode" ID="6" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/FileInode$1"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/FileInode$0"/> </tuple>
   <types> <type ID="4"/> <type ID="7"/> </types>
</field>

<field label="name_qw_set" ID="8" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="2"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="2"/> </tuple>
   <types> <type ID="4"/> <type ID="1"/> </types>
</field>

<field label="rename_pointer" ID="9" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/Dentry$1"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/Dentry$0"/> </tuple>
   <types> <type ID="4"/> <type ID="4"/> </types>
</field>

<sig label="defs/Root" ID="10" parentID="11" one="yes">
   <atom label="defs/Root$0"/>
</sig>

<sig label="defs/DirInode" ID="11" parentID="7">
</sig>

<sig label="defs/FileInode" ID="12" parentID="7">
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
</sig>

<sig label="defs/Inode" ID="7" parentID="5" abstract="yes">
</sig>

<field label="link_count" ID="13" parentID="7" var="yes">
   <tuple> <atom label="defs/Root$0"/> <atom label="2"/> </tuple>
   <tuple> <atom label="defs/FileInode$0"/> <atom label="1"/> </tuple>
   <tuple> <atom label="defs/FileInode$1"/> <atom label="1"/> </tuple>
   <types> <type ID="7"/> <type ID="1"/> </types>
</field>

<sig label="defs/DataPageHeader" ID="14" parentID="15">
</sig>

<sig label="defs/DirPageHeader" ID="16" parentID="15">
   <atom label="defs/DirPageHeader$0"/>
   <atom label="defs/DirPageHeader$1"/>
</sig>

<field label="parent_ino" ID="17" parentID="16" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="16"/> <type ID="7"/> </types>
</field>

<field label="dentries" ID="18" parentID="16" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Dentry$1"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Dentry$0"/> </tuple>
   <types> <type ID="16"/> <type ID="4"/> </types>
</field>

<sig label="defs/PageHeader" ID="15" parentID="5" abstract="yes">
</sig>

<field label="inode" ID="19" parentID="15" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="15"/> <type ID="7"/> </types>
</field>

<sig label="defs/PMObj" ID="5" parentID="2" abstract="yes">
</sig>

<field label="typestate" ID="20" parentID="5" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/SetRenamePointer$0"/> </tuple>
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/Renaming$0"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/SetRenamePointer$0"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/Renaming$0"/> </tuple>
   <types> <type ID="5"/> <type ID="21"/> </types>
</field>

<sig label="defs/Start" ID="22" parentID="21" one="yes">
   <atom label="defs/Start$0"/>
</sig>

<sig label="defs/Free" ID="23" parentID="21" one="yes">
   <atom label="defs/Free$0"/>
</sig>

<sig label="defs/AllocStarted" ID="24" parentID="21" one="yes">
   <atom label="defs/AllocStarted$0"/>
</sig>

<sig label="defs/Alloc" ID="25" parentID="21" one="yes">
   <atom label="defs/Alloc$0"/>
</sig>

<sig label="defs/Init" ID="26" parentID="21" one="yes">
   <atom label="defs/Init$0"/>
</sig>

<sig label="defs/Complete" ID="27" parentID="21" one="yes">
   <atom label="defs/Complete$0"/>
</sig>

<sig label="defs/IncLink" ID="28" parentID="21" one="yes">
   <atom label="defs/IncLink$0"/>
</sig>

<sig label="defs/SetRenamePointer" ID="29" parentID="21" one="yes">
   <atom label="defs/SetRenamePointer$0"/>
</sig>

<sig label="defs/InitRenamePointer" ID="30" parentID="21" one="yes">
   <atom label="defs/InitRenamePointer$0"/>
</sig>

<sig label="defs/ClearRenamePointer" ID="31" parentID="21" one="yes">
   <atom label="defs/ClearRenamePointer$0"/>
</sig>

<sig label="defs/Renaming" ID="32" parentID="21" one="yes">
   <atom label="defs/Renaming$0"/>
</sig>

<sig label="defs/Renamed" ID="33" parentID="21" one="yes">
   <atom label="defs/Renamed$0"/>
</sig>

<sig label="defs/ClearIno" ID="34" parentID="21" one="yes">
   <atom label="defs/ClearIno$0"/>
</sig>

<sig label="defs/DeallocStart" ID="35" parentID="21" one="yes">
   <atom label="defs/DeallocStart$0"/>
</sig>

<sig label="defs/Dealloc" ID="36" parentID="21" one="yes">
   <atom label="defs/Dealloc$0"/>
</sig>

<sig label="defs/OpTypestate" ID="21" parentID="2" abstract="yes">
</sig>

<sig label="defs/Volatile" ID="37" parentID="2" one="yes">
   <atom label="defs/Volatile$0"/>
</sig>

<field label="parent" ID="38" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/FileInode$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/FileInode$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="37"/> <type ID="7"/> <type ID="11"/> </types>
</field>

<field label="children" ID="39" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/FileInode$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/FileInode$1"/> </tuple>
   <types> <type ID="37"/> <type ID="11"/> <type ID="7"/> </types>
</field>

<field label="owns" ID="40" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$1"/> </tuple>
   <types> <type ID="37"/> <type ID="7"/> <type ID="15"/> </types>
</field>

<sig label="univ" ID="2" builtin="yes" var="yes">
</sig>

<sig label="defs/InodeValues" ID="41" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="7"/>
</sig>

<sig label="defs/InodeSet" ID="42" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/LcSet" ID="43" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/MetadataSet" ID="44" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/TypeSet" ID="45" var="yes">
   <type ID="15"/>
</sig>

<sig label="defs/Dirty" ID="46" var="yes">
   <atom label="defs/Dentry$0"/>
   <type ID="5"/>
</sig>

<sig label="defs/InFlight" ID="47" var="yes">
   <atom label="defs/Dentry$1"/>
   <type ID="5"/>
</sig>

<sig label="defs/Clean" ID="48" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <atom label="defs/DirPageHeader$0"/>
   <atom label="defs/DirPageHeader$1"/>
   <type ID="5"/>
</sig>

<skolem label="$irp_transition_p" ID="49">
   <tuple> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$0"/> </tuple>
   <types> <type ID="11"/> <type ID="16"/> </types>
</skolem>

<skolem label="$irp_transition_dst" ID="50">
   <tuple> <atom label="defs/Dentry$1"/> </tuple>
   <types> <type ID="4"/> </types>
</skolem>

</instance>
<instance bitwidth="4" maxseq="4" mintrace="1" maxtrace="25" command="Check irp_transition for 1..25 steps, 1 Volatile, 7 PMObj" filename="/home/hayley/fs-modeling/persistence_checks.als" tracelength="6" backloop="5">

<sig label="seq/Int" ID="0" parentID="1" builtin="yes">
</sig>

<sig label="Int" ID="1" parentID="2" builtin="yes">
</sig>

<sig label="String" ID="3" parentID="2" builtin="yes">
</sig>

<sig label="defs/Dentry" ID="4" parentID="5" some="yes">
   <atom label="defs/Dentry$0"/>
   <atom label="defs/Dentry$1"/>
</sig>

<field label="inode" ID="6" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/FileInode$1"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/FileInode$0"/> </tuple>
   <types> <type ID="4"/> <type ID="7"/> </types>
</field>

<field label="name_qw_set" ID="8" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="2"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="2"/> </tuple>
   <types> <type ID="4"/> <type ID="1"/> </types>
</field>

<field label="rename_pointer" ID="9" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/Dentry$1"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/Dentry$0"/> </tuple>
   <types> <type ID="4"/> <type ID="4"/> </types>
</field>

<sig label="defs/Root" ID="10" parentID="11" one="yes">
   <atom label="defs/Root$0"/>
</sig>

<sig label="defs/DirInode" ID="11" parentID="7">
</sig>

<sig label="defs/FileInode" ID="12" parentID="7">
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
</sig>

<sig label="defs/Inode" ID="7" parentID="5" abstract="yes">
</sig>

<field label="link_count" ID="13" parentID="7" var="yes">
   <tuple> <atom label="defs/Root$0"/> <atom label="2"/> </tuple>
   <tuple> <atom label="defs/FileInode$0"/> <atom label="1"/> </tuple>
   <tuple> <atom label="defs/FileInode$1"/> <atom label="1"/> </tuple>
   <types> <type ID="7"/> <type ID="1"/> </types>
</field>

<sig label="defs/DataPageHeader" ID="14" parentID="15">
</sig>

<sig label="defs/DirPageHeader" ID="16" parentID="15">
   <atom label="defs/DirPageHeader$0"/>
   <atom label="defs/DirPageHeader$1"/>
</sig>

<field label="parent_ino" ID="17" parentID="16" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="16"/> <type ID="7"/> </types>
</field>

<field label="dentries" ID="18" parentID="16" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Dentry$1"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Dentry$0"/> </tuple>
   <types> <type ID="16"/> <type ID="4"/> </types>
</field>

<sig label="defs/PageHeader" ID="15" parentID="5" abstract="yes">
</sig>

<field label="inode" ID="19" parentID="15" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="15"/> <type ID="7"/> </types>
</field>

<sig label="defs/PMObj" ID="5" parentID="2" abstract="yes">
</sig>

<field label="typestate" ID="20" parentID="5" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/SetRenamePointer$0"/> </tuple>
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/Renaming$0"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/SetRenamePointer$0"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/Renaming$0"/> </tuple>
   <types> <type ID="5"/> <type ID="21"/> </types>
</field>

<sig label="defs/Start" ID="22" parentID="21" one="yes">
   <atom label="defs/Start$0"/>
</sig>

<sig label="defs/Free" ID="23" parentID="21" one="yes">
   <atom label="defs/Free$0"/>
</sig>

<sig label="defs/AllocStarted" ID="24" parentID="21" one="yes">
   <atom label="defs/AllocStarted$0"/>
</sig>

<sig label="defs/Alloc" ID="25" parentID="21" one="yes">
   <atom label="defs/Alloc$0"/>
</sig>

<sig label="defs/Init" ID="26" parentID="21" one="yes">
   <atom label="defs/Init$0"/>
</sig>

<sig label="defs/Complete" ID="27" parentID="21" one="yes">
   <atom label="defs/Complete$0"/>
</sig>

<sig label="defs/IncLink" ID="28" parentID="21" one="yes">
   <atom label="defs/IncLink$0"/>
</sig>

<sig label="defs/SetRenamePointer" ID="29" parentID="21" one="yes">
   <atom label="defs/SetRenamePointer$0"/>
</sig>

<sig label="defs/InitRenamePointer" ID="30" parentID="21" one="yes">
   <atom label="defs/InitRenamePointer$0"/>
</sig>

<sig label="defs/ClearRenamePointer" ID="31" parentID="21" one="yes">
   <atom label="defs/ClearRenamePointer$0"/>
</sig>

<sig label="defs/Renaming" ID="32" parentID="21" one="yes">
   <atom label="defs/Renaming$0"/>
</sig>

<sig label="defs/Renamed" ID="33" parentID="21" one="yes">
   <atom label="defs/Renamed$0"/>
</sig>

<sig label="defs/ClearIno" ID="34" parentID="21" one="yes">
   <atom label="defs/ClearIno$0"/>
</sig>

<sig label="defs/DeallocStart" ID="35" parentID="21" one="yes">
   <atom label="defs/DeallocStart$0"/>
</sig>

<sig label="defs/Dealloc" ID="36" parentID="21" one="yes">
   <atom label="defs/Dealloc$0"/>
</sig>

<sig label="defs/OpTypestate" ID="21" parentID="2" abstract="yes">
</sig>

<sig label="defs/Volatile" ID="37" parentID="2" one="yes">
   <atom label="defs/Volatile$0"/>
</sig>

<field label="parent" ID="38" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/FileInode$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/FileInode$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="37"/> <type ID="7"/> <type ID="11"/> </types>
</field>

<field label="children" ID="39" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/FileInode$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/FileInode$1"/> </tuple>
   <types> <type ID="37"/> <type ID="11"/> <type ID="7"/> </types>
</field>

<field label="owns" ID="40" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$1"/> </tuple>
   <types> <type ID="37"/> <type ID="7"/> <type ID="15"/> </types>
</field>

<sig label="univ" ID="2" builtin="yes" var="yes">
</sig>

<sig label="defs/InodeValues" ID="41" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="7"/>
</sig>

<sig label="defs/InodeSet" ID="42" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/LcSet" ID="43" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/MetadataSet" ID="44" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/TypeSet" ID="45" var="yes">
   <type ID="15"/>
</sig>

<sig label="defs/Dirty" ID="46" var="yes">
   <atom label="defs/Dentry$0"/>
   <type ID="5"/>
</sig>

<sig label="defs/InFlight" ID="47" var="yes">
   <type ID="5"/>
</sig>

<sig label="defs/Clean" ID="48" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <atom label="defs/DirPageHeader$0"/>
   <atom label="defs/DirPageHeader$1"/>
   <atom label="defs/Dentry$1"/>
   <type ID="5"/>
</sig>

<skolem label="$irp_transition_p" ID="49">
   <tuple> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$0"/> </tuple>
   <types> <type ID="11"/> <type ID="16"/> </types>
</skolem>

<skolem label="$irp_transition_dst" ID="50">
   <tuple> <atom label="defs/Dentry$1"/> </tuple>
   <types> <type ID="4"/> </types>
</skolem>

</instance>
<instance bitwidth="4" maxseq="4" mintrace="1" maxtrace="25" command="Check irp_transition for 1..25 steps, 1 Volatile, 7 PMObj" filename="/home/hayley/fs-modeling/persistence_checks.als" tracelength="6" backloop="5">

<sig label="seq/Int" ID="0" parentID="1" builtin="yes">
</sig>

<sig label="Int" ID="1" parentID="2" builtin="yes">
</sig>

<sig label="String" ID="3" parentID="2" builtin="yes">
</sig>

<sig label="defs/Dentry" ID="4" parentID="5" some="yes">
   <atom label="defs/Dentry$0"/>
   <atom label="defs/Dentry$1"/>
</sig>

<field label="inode" ID="6" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/FileInode$1"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/FileInode$1"/> </tuple>
   <types> <type ID="4"/> <type ID="7"/> </types>
</field>

<field label="name_qw_set" ID="8" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="2"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="2"/> </tuple>
   <types> <type ID="4"/> <type ID="1"/> </types>
</field>

<field label="rename_pointer" ID="9" parentID="4" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/Dentry$1"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/Dentry$0"/> </tuple>
   <types> <type ID="4"/> <type ID="4"/> </types>
</field>

<sig label="defs/Root" ID="10" parentID="11" one="yes">
   <atom label="defs/Root$0"/>
</sig>

<sig label="defs/DirInode" ID="11" parentID="7">
</sig>

<sig label="defs/FileInode" ID="12" parentID="7">
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
</sig>

<sig label="defs/Inode" ID="7" parentID="5" abstract="yes">
</sig>

<field label="link_count" ID="13" parentID="7" var="yes">
   <tuple> <atom label="defs/Root$0"/> <atom label="2"/> </tuple>
   <tuple> <atom label="defs/FileInode$0"/> <atom label="1"/> </tuple>
   <tuple> <atom label="defs/FileInode$1"/> <atom label="1"/> </tuple>
   <types> <type ID="7"/> <type ID="1"/> </types>
</field>

<sig label="defs/DataPageHeader" ID="14" parentID="15">
</sig>

<sig label="defs/DirPageHeader" ID="16" parentID="15">
   <atom label="defs/DirPageHeader$0"/>
   <atom label="defs/DirPageHeader$1"/>
</sig>

<field label="parent_ino" ID="17" parentID="16" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="16"/> <type ID="7"/> </types>
</field>

<field label="dentries" ID="18" parentID="16" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Dentry$1"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Dentry$0"/> </tuple>
   <types> <type ID="16"/> <type ID="4"/> </types>
</field>

<sig label="defs/PageHeader" ID="15" parentID="5" abstract="yes">
</sig>

<field label="inode" ID="19" parentID="15" var="yes">
   <tuple> <atom label="defs/DirPageHeader$0"/> <atom label="defs/Root$0"/> </tuple>
   <tuple> <atom label="defs/DirPageHeader$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="15"/> <type ID="7"/> </types>
</field>

<sig label="defs/PMObj" ID="5" parentID="2" abstract="yes">
</sig>

<field label="typestate" ID="20" parentID="5" var="yes">
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/SetRenamePointer$0"/> </tuple>
   <tuple> <atom label="defs/Dentry$0"/> <atom label="defs/Renamed$0"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/InitRenamePointer$0"/> </tuple>
   <tuple> <atom label="defs/Dentry$1"/> <atom label="defs/Renaming$0"/> </tuple>
   <types> <type ID="5"/> <type ID="21"/> </types>
</field>

<sig label="defs/Start" ID="22" parentID="21" one="yes">
   <atom label="defs/Start$0"/>
</sig>

<sig label="defs/Free" ID="23" parentID="21" one="yes">
   <atom label="defs/Free$0"/>
</sig>

<sig label="defs/AllocStarted" ID="24" parentID="21" one="yes">
   <atom label="defs/AllocStarted$0"/>
</sig>

<sig label="defs/Alloc" ID="25" parentID="21" one="yes">
   <atom label="defs/Alloc$0"/>
</sig>

<sig label="defs/Init" ID="26" parentID="21" one="yes">
   <atom label="defs/Init$0"/>
</sig>

<sig label="defs/Complete" ID="27" parentID="21" one="yes">
   <atom label="defs/Complete$0"/>
</sig>

<sig label="defs/IncLink" ID="28" parentID="21" one="yes">
   <atom label="defs/IncLink$0"/>
</sig>

<sig label="defs/SetRenamePointer" ID="29" parentID="21" one="yes">
   <atom label="defs/SetRenamePointer$0"/>
</sig>

<sig label="defs/InitRenamePointer" ID="30" parentID="21" one="yes">
   <atom label="defs/InitRenamePointer$0"/>
</sig>

<sig label="defs/ClearRenamePointer" ID="31" parentID="21" one="yes">
   <atom label="defs/ClearRenamePointer$0"/>
</sig>

<sig label="defs/Renaming" ID="32" parentID="21" one="yes">
   <atom label="defs/Renaming$0"/>
</sig>

<sig label="defs/Renamed" ID="33" parentID="21" one="yes">
   <atom label="defs/Renamed$0"/>
</sig>

<sig label="defs/ClearIno" ID="34" parentID="21" one="yes">
   <atom label="defs/ClearIno$0"/>
</sig>

<sig label="defs/DeallocStart" ID="35" parentID="21" one="yes">
   <atom label="defs/DeallocStart$0"/>
</sig>

<sig label="defs/Dealloc" ID="36" parentID="21" one="yes">
   <atom label="defs/Dealloc$0"/>
</sig>

<sig label="defs/OpTypestate" ID="21" parentID="2" abstract="yes">
</sig>

<sig label="defs/Volatile" ID="37" parentID="2" one="yes">
   <atom label="defs/Volatile$0"/>
</sig>

<field label="parent" ID="38" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/FileInode$1"/> <atom label="defs/Root$0"/> </tuple>
   <types> <type ID="37"/> <type ID="7"/> <type ID="11"/> </types>
</field>

<field label="children" ID="39" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/FileInode$1"/> </tuple>
   <types> <type ID="37"/> <type ID="11"/> <type ID="7"/> </types>
</field>

<field label="owns" ID="40" parentID="37" var="yes">
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$0"/> </tuple>
   <tuple> <atom label="defs/Volatile$0"/> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$1"/> </tuple>
   <types> <type ID="37"/> <type ID="7"/> <type ID="15"/> </types>
</field>

<sig label="univ" ID="2" builtin="yes" var="yes">
</sig>

<sig label="defs/InodeValues" ID="41" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="7"/>
</sig>

<sig label="defs/InodeSet" ID="42" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/LcSet" ID="43" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/MetadataSet" ID="44" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <type ID="41"/>
</sig>

<sig label="defs/TypeSet" ID="45" var="yes">
   <type ID="15"/>
</sig>

<sig label="defs/Dirty" ID="46" var="yes">
   <atom label="defs/Dentry$0"/>
   <atom label="defs/Dentry$1"/>
   <type ID="5"/>
</sig>

<sig label="defs/InFlight" ID="47" var="yes">
   <type ID="5"/>
</sig>

<sig label="defs/Clean" ID="48" var="yes">
   <atom label="defs/Root$0"/>
   <atom label="defs/FileInode$0"/>
   <atom label="defs/FileInode$1"/>
   <atom label="defs/DirPageHeader$0"/>
   <atom label="defs/DirPageHeader$1"/>
   <type ID="5"/>
</sig>

<skolem label="$irp_transition_p" ID="49">
   <tuple> <atom label="defs/Root$0"/> <atom label="defs/DirPageHeader$0"/> </tuple>
   <types> <type ID="11"/> <type ID="16"/> </types>
</skolem>

<skolem label="$irp_transition_dst" ID="50">
   <tuple> <atom label="defs/Dentry$1"/> </tuple>
   <types> <type ID="4"/> </types>
</skolem>

</instance>

<source filename="/home/hayley/fs-modeling/persistence_checks.als" content="open defs&#x000a;open transitions&#x000a;open util/integer&#x000a;open model2&#x000a;&#x000a;// TODO: it might be simpler (conceptually, not necessarily to code) and potentially more correct&#x000a;// to require that any op state change requires all involved objects to be clean&#x000a;&#x000a;// some experiments in reasoning about persistence state across op states and transitions&#x000a;// NOTE: if any of these fail, they need to be copied and re-run in the model2.als&#x000a;// file in order to properly visualize them with transitions&#x000a;&#x000a;// NOTE: s should be a persistence state or op state set! &#x000a;// next_state_change tells us if i will be moved into state s by the next transition&#x000a;pred next_state_change[o: PMObj, s: OpTypestate] {&#x000a;    // o !in s and o in s&apos;&#x000a;    s !in o.typestate and s in o.(typestate&apos;)&#x000a;}&#x000a;// next state change tells us if i will be moved out of state s by the next transition &#x000a;pred prev_state_change[o: PMObj, s: OpTypestate] {&#x000a;    // o in s and o !in s&apos;&#x000a;    s in o.typestate and s !in o.(typestate&apos;)&#x000a;}&#x000a;&#x000a;start_transition: check {&#x000a;    always (all i: PMObj | (next_state_change[i, Start] || prev_state_change[i, Start]) =&gt; i in Clean)&#x000a;} for 1 Volatile, 7 PMObj, 1..21 steps&#x000a;&#x000a;complete_transition: check {&#x000a;    always (all i: PMObj | (next_state_change[i, Complete] || prev_state_change[i, Complete]) =&gt; i in Clean)&#x000a;} for 1 Volatile, 7 PMObj, 1..21 steps&#x000a;&#x000a;init_transition: check {&#x000a;    always (all i: PMObj | (next_state_change[i, Init] || prev_state_change[i, Init]) =&gt; i in Clean)&#x000a;} for 1 Volatile, 7 PMObj, 1..21 steps&#x000a;&#x000a;alloc_started_transition: check {&#x000a;    always (all i: PMObj | next_state_change[i, AllocStarted] =&gt; i in Clean)&#x000a;} for 1 Volatile, 7 PMObj, 1..21 steps&#x000a;&#x000a;alloc_transition: check {&#x000a;    always (all i: PMObj | prev_state_change[i, Alloc] =&gt; i in Clean)&#x000a;} for 1 Volatile, 7 PMObj, 1..21 steps&#x000a;&#x000a;// only inodes can be in IncLink state, so we only need to quantify over them and not the whole set of objects&#x000a;inc_link_transition: check {&#x000a;    always (all i: Inode | (prev_state_change[i, IncLink]) =&gt; i in Clean)&#x000a;} for 1 Volatile, 7 PMObj, 1..21 steps&#x000a;&#x000a;// TODO: say something about the other dentry when leaving a state&#x000a;srp_transition: check {&#x000a;    always (all dst: Dentry {&#x000a;        (next_state_change[dst, SetRenamePointer] =&gt; &#x000a;            (dst in Clean and (some src: Dentry | next_state_change[src, Renaming] and src in Clean)))&#x000a;        and &#x000a;        (prev_state_change[dst, SetRenamePointer] =&gt; dst in Clean)&#x000a;    })&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;irp_transition: check {&#x000a;    always (all dst: Dentry {&#x000a;        (next_state_change[dst, InitRenamePointer] =&gt; &#x000a;            (dst in Clean and (some src: Dentry | next_state_change[src, Renamed] and src in Clean)))&#x000a;        and &#x000a;        (prev_state_change[dst, InitRenamePointer] =&gt; dst in Clean)&#x000a;    })&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;clear_ino_renamed_transition: check {&#x000a;    always (all src: Dentry {&#x000a;        (next_state_change[src, ClearIno] =&gt; &#x000a;            (src in Clean and (some dst: Dentry | InitRenamePointer in dst.typestate and dst in Clean)))&#x000a;        and &#x000a;        (prev_state_change[src, ClearIno] =&gt; src in Clean)&#x000a;    })&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;crp_transition: check {&#x000a;    always (all dst: Dentry {&#x000a;        (next_state_change[dst, ClearRenamePointer] =&gt;&#x000a;            (dst in Clean and (some src: Dentry | ClearIno in src.typestate and src in Clean)))&#x000a;        and &#x000a;        (prev_state_change[dst, ClearRenamePointer] =&gt; dst in Clean)&#x000a;    })&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;dealloc_transition: check {&#x000a;    always (all src: Dentry {&#x000a;        (next_state_change[src, Dealloc] =&gt; &#x000a;            (src in Clean and (some dst: Dentry | dst in Clean and ClearRenamePointer in dst.typestate)))&#x000a;        and &#x000a;        (prev_state_change[src, Dealloc] =&gt; src in Clean)&#x000a;    })&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps"/>

<source filename="/$alloy4$/models/util/integer.als" content="module util/integer&#x000a;&#x000a;/*&#x000a; * A collection of utility functions for using Integers in Alloy.&#x000a; * Note that integer overflows are silently truncated to the current bitwidth&#x000a; * using the 2&apos;s complement arithmetic, unless the &quot;forbid overfows&quot; option is&#x000a; * turned on, in which case only models that don&apos;t have any overflows are &#x000a; * analyzed. &#x000a; */&#x000a;&#x000a;fun add  [n1, n2: Int] : Int { this/plus[n1, n2] }&#x000a;fun plus [n1, n2: Int] : Int { n1 fun/add n2 }&#x000a;&#x000a;fun sub   [n1, n2: Int] : Int { this/minus[n1, n2] }&#x000a;fun minus [n1, n2: Int] : Int { n1 fun/sub n2 }&#x000a;&#x000a;fun mul [n1, n2: Int] : Int { n1 fun/mul n2 }&#x000a;&#x000a;/**&#x000a; * Performs the division with &quot;round to zero&quot; semantics, except the following 3 cases&#x000a; * 1) if a is 0, then it returns 0&#x000a; * 2) else if b is 0, then it returns 1 if a is negative and -1 if a is positive&#x000a; * 3) else if a is the smallest negative integer, and b is -1, then it returns a&#x000a; */&#x000a;fun div [n1, n2: Int] : Int { n1 fun/div n2 }&#x000a;&#x000a;/** answer is defined to be the unique integer that satisfies &quot;a = ((a/b)*b) + remainder&quot; */&#x000a;fun rem [n1, n2: Int] : Int { n1 fun/rem n2 }&#x000a;&#x000a;/** negate */&#x000a;fun negate [n: Int] : Int { 0 fun/sub n }&#x000a;&#x000a;/** equal to */&#x000a;pred eq [n1, n2: Int] { int[n1] = int[n2] }&#x000a;&#x000a;/** greater than */&#x000a;pred gt [n1, n2: Int] { n1 &gt; n2 }&#x000a;&#x000a;/** less then */&#x000a;pred lt [n1, n2: Int] { n1 &lt; n2 }&#x000a;&#x000a;/** greater than or equal */&#x000a;pred gte [n1, n2: Int] { n1 &gt;= n2 }&#x000a;&#x000a;/** less than or equal */&#x000a;pred lte [n1, n2: Int] { n1 &lt;= n2 }&#x000a;&#x000a;/** integer is zero */&#x000a;pred zero [n: Int] { n = 0 }&#x000a;&#x000a;/** positive */&#x000a;pred pos  [n: Int] { n &gt; 0 }&#x000a;&#x000a;/** negative */&#x000a;pred neg  [n: Int] { n &lt; 0 }&#x000a;&#x000a;/** non-positive */&#x000a;pred nonpos [n: Int] { n &lt;= 0 }&#x000a;&#x000a;/** non-negative */&#x000a;pred nonneg [n: Int] { n &gt;= 0 }&#x000a;&#x000a;/** signum (aka sign or sgn) */&#x000a;fun signum [n: Int] : Int { n&lt;0 =&gt; (0 fun/sub 1) else (n&gt;0 =&gt; 1 else 0) }&#x000a;&#x000a;/**&#x000a; * returns the ith element (zero-based) from the set s&#x000a; * in the ordering of &apos;next&apos;, which is a linear ordering&#x000a; * relation like that provided by util/ordering&#x000a; */&#x000a;fun int2elem[i: Int, next: univ-&gt;univ, s: set univ] : lone s {&#x000a;  {e: s | #^next.e = int i }&#x000a;}&#x000a;&#x000a;/**&#x000a; * returns the index of the element (zero-based) in the&#x000a; * ordering of next, which is a linear ordering relation&#x000a; * like that provided by util/ordering&#x000a; */&#x000a;fun elem2int[e: univ, next: univ-&gt;univ] : lone Int {&#x000a;  Int[#^next.e]&#x000a;}&#x000a;&#x000a;/** returns the largest integer in the current bitwidth */&#x000a;fun max:one Int { fun/max }&#x000a;&#x000a;/** returns the smallest integer in the current bitwidth */&#x000a;fun min:one Int { fun/min }&#x000a;&#x000a;/** maps each integer (except max) to the integer after it */&#x000a;fun next:Int-&gt;Int { fun/next }&#x000a;&#x000a;/** maps each integer (except min) to the integer before it */&#x000a;fun prev:Int-&gt;Int { ~next }&#x000a;&#x000a;/** given a set of integers, return the largest element */&#x000a;fun max [es: set Int]: lone Int { es - es.^prev }&#x000a;&#x000a;/** given a set of integers, return the smallest element */&#x000a;fun min [es: set Int]: lone Int { es - es.^next }&#x000a;&#x000a;/** given an integer, return all integers prior to it */&#x000a;fun prevs [e: Int]: set Int { e.^prev }&#x000a;&#x000a;/** given an integer, return all integers following it */&#x000a;fun nexts [e: Int]: set Int { e.^next }&#x000a;&#x000a;/** returns the larger of the two integers */&#x000a;fun larger [e1, e2: Int]: Int { let a=int[e1], b=int[e2] | (a&lt;b =&gt; b else a) }&#x000a;&#x000a;/** returns the smaller of the two integers */&#x000a;fun smaller [e1, e2: Int]: Int { let a=int[e1], b=int[e2] | (a&lt;b =&gt; a else b) }&#x000a;"/>

<source filename="/home/hayley/fs-modeling/defs.als" content="open util/integer&#x000a;&#x000a;// macros for managing frame conditions&#x000a;let unchanged[x] = { (x&apos;) = (x) }&#x000a;let pm_states_unchanged = {&#x000a;    unchanged[Clean]&#x000a;    unchanged[InFlight]&#x000a;    unchanged[Dirty]&#x000a;}&#x000a;let make_dirty[x] = {&#x000a;    Dirty&apos; = Dirty + x&#x000a;    Clean&apos; = Clean - x&#x000a;    InFlight&apos; = InFlight - x&#x000a;}&#x000a;let op_states_unchanged = {&#x000a;    all o: PMObj | unchanged[o.typestate]&#x000a;}&#x000a;&#x000a;&#x000a;// persistent objects&#x000a;abstract sig PMObj {&#x000a;    var typestate: set OpTypestate&#x000a;}&#x000a;some sig Dentry extends PMObj {&#x000a;    var inode: lone Inode,&#x000a;    var name_qw_set: lone Int,&#x000a;    var rename_pointer: lone Dentry&#x000a;}&#x000a;abstract sig Inode extends PMObj {&#x000a;    var link_count: lone Int&#x000a;} {&#x000a;    always (gte[link_count, 0])&#x000a;}&#x000a;sig DirInode extends Inode {}&#x000a;sig FileInode extends Inode {}&#x000a;abstract sig PageHeader extends PMObj {&#x000a;    var inode: lone Inode&#x000a;}&#x000a;sig DataPageHeader extends PageHeader {}&#x000a;sig DirPageHeader extends PageHeader {&#x000a;    var parent_ino: lone Inode,&#x000a;    var dentries: set Dentry&#x000a;}&#x000a;&#x000a;// if an inode is in one of these sets, the corresponding value has been set in the &#x000a;// inode (but it may or may not be persistent)&#x000a;var sig InodeValues in Inode {}&#x000a;// MetadataSet represents all metadata not covered by the other sets&#x000a;var sig InodeSet, LcSet, MetadataSet in InodeValues {}&#x000a;&#x000a;// represents whether the type field of a page header has been set&#x000a;// other page header fields are represented as fields in their sigs&#x000a;var sig TypeSet in PageHeader {}&#x000a;&#x000a;one sig Root extends DirInode {}&#x000a;&#x000a;abstract sig OpTypestate {}&#x000a;one sig Start, Free, AllocStarted, Alloc, Init, Complete, IncLink, &#x000a;        SetRenamePointer, InitRenamePointer, ClearRenamePointer, Renaming,&#x000a;        Renamed, ClearIno, DeallocStart, Dealloc extends OpTypestate {}&#x000a;&#x000a;// persistence states&#x000a;var sig Dirty, InFlight, Clean in PMObj {}&#x000a;&#x000a;// general constraints&#x000a;// TODO: some of these should be specified in init and then checked in subsequent execution&#x000a;&#x000a;// the root inode is not pointed to by any dentries&#x000a;fact {&#x000a;    always (all d: Dentry | d.inode != Root)&#x000a;}&#x000a;// each object can only be in one persistence state at a time&#x000a;fact {&#x000a;    always (disj[Dirty, InFlight, Clean])&#x000a;}&#x000a;// dentries always must belong to one page header&#x000a;fact {&#x000a;    always (all d: Dentry | one p: DirPageHeader | d in p.dentries )&#x000a;}&#x000a;&#x000a;fact {&#x000a;    always (all d: DirInode - Root, p: DirPageHeader | d in p.inode =&gt; d !in p.parent_ino)&#x000a;}&#x000a;&#x000a;// TODO: can we make this stuff auxiliary relations rather than its own Volatile thingy?&#x000a;// might be cleanear in the visualization, but also might be harder to model in code&#x000a;one sig Volatile {&#x000a;    // var parent: Inode -&gt; lone DirInode, // TODO: need to adjust for hard links&#x000a;    // var children: DirInode lone -&gt; Inode, // TODO: need to adjust for hard links&#x000a;    var parent: Inode -&gt; DirInode, &#x000a;    var children: DirInode -&gt; Inode, &#x000a;    var owns: Inode lone -&gt; set PageHeader,&#x000a;} {&#x000a;    always (no Root.parent)&#x000a;&#x000a;    // defining owns relation - i owns p if p points to i&#x000a;    always (all i: Inode, p: PageHeader | i in p.inode &lt;=&gt; p in i.owns)&#x000a;&#x000a;    // i is j&apos;s parent if j is pointed to by a dentry in i and the dentry has not been renamed&#x000a;    always (all i: DirInode, j: Inode {&#x000a;        i in j.parent &lt;=&gt; (some d: Dentry | d in i.owns.dentries and Renamed !in d.typestate and j in d.inode)&#x000a;    })&#x000a;&#x000a;    // i cannot be an ancestor of its own parent &#x000a;    always (all i: Inode | i !in i.^parent)&#x000a;&#x000a;    // children relation is inverse of parent relation&#x000a;    always (children = ~parent)&#x000a;}&#x000a;&#x000a;fun dentry_parent : Dentry -&gt; Inode {&#x000a;    { d: Dentry, i: Inode | d in i.(Volatile.owns).dentries}&#x000a;}&#x000a;&#x000a;fun dentry_belongs_to : Dentry-&gt;DirPageHeader {&#x000a;    { d: Dentry, p: DirPageHeader | d in p.dentries }&#x000a;}&#x000a;&#x000a;fun linked_dentries : Inode -&gt; Dentry {&#x000a;    { i: Inode, d: Dentry | (i in d.inode and Renamed !in d.typestate) }&#x000a;}&#x000a;&#x000a;fun child_directories : Inode -&gt; set DirInode {&#x000a;    { i: Inode, d: DirInode | d in i.(Volatile.children) }&#x000a;}&#x000a;&#x000a;fact link_count_set {&#x000a;    always (all i: Inode | some i.link_count &lt;=&gt; i in LcSet)&#x000a;}&#x000a;&#x000a;&#x000a;// initial state&#x000a;fact init {&#x000a;    no Dirty and &#x000a;    no InFlight and &#x000a;    no Root.typestate and &#x000a;    (all o: PMObj | o in Clean) and &#x000a;    (all o: PMObj | o.typestate = Free or no o.typestate) and // objects never start out in an intermediate operation state&#x000a;    (all i: Inode | Free in i.typestate =&gt; inode_clear[i]) and &#x000a;    (all d: Dentry | Free in d.typestate =&gt; dentry_clear[d]) and &#x000a;    (all p: DirPageHeader | Free in p.typestate =&gt; dir_page_header_clear[p]) and &#x000a;    (all p: DataPageHeader | Free in p.typestate =&gt; data_page_header_clear[p]) and &#x000a;    // (all o: PMObj | Free in o.typestate =&gt; Start !in o.typestate) and &#x000a;    (all o: PMObj | AllocStarted !in o.typestate and Alloc !in o.typestate and Init !in o.typestate and &#x000a;                    IncLink !in o.typestate and SetRenamePointer !in o.typestate and InitRenamePointer !in o.typestate and &#x000a;                    ClearRenamePointer !in o.typestate and Renaming !in o.typestate and Renamed !in o.typestate and &#x000a;                    ClearIno !in o.typestate and DeallocStart !in o.typestate and Dealloc !in o.typestate and &#x000a;                    Complete !in o.typestate) and &#x000a;    (all d: Dentry | Free in d.typestate &lt;=&gt; no d.inode) and // free directory entries don&apos;t point to inodes&#x000a;    (all p: PageHeader | Free in p.typestate =&gt; no p.inode) and // free pages don&apos;t point to inodes&#x000a;    (all p: PageHeader, i: Inode | Free in i.typestate =&gt; i !in p.inode) and  // pages don&apos;t point to free inodes&#x000a;    (all p: DirPageHeader, d: p.dentries | Free in p.typestate =&gt; Free in d.typestate) and // all dentries belonging to a free page are also free&#x000a;    (all p: DirPageHeader | Free in p.typestate =&gt; no p.parent_ino) and // free pages do not point to a parent directory&#x000a;    (all p: DirPageHeader, i: DirInode | Free in i.typestate =&gt; i !in p.parent_ino) and // a free inode cannot be a parent &#x000a;    (all i: Inode | Free !in i.typestate =&gt; inode_alloc_done[i]) and // non-free inodes are fully allocated&#x000a;    (all i: Inode | Free in i.typestate =&gt; inode_clear[i]) and // free inodes have no fields set&#x000a;    initial_link_count and &#x000a;    (all d: Dentry | Free !in d.typestate =&gt; dentry_alloc_done[d]) and // non-free dentries are fully allocated&#x000a;    (all d: Dentry | Free in d.typestate =&gt; dentry_clear[d]) and // free dentries have no fields set&#x000a;    (all d: Dentry, i: Inode | Free in i.typestate =&gt; i !in d.inode) and // dentries do not point to free pages&#x000a;    (all p: DataPageHeader | Free in p.typestate =&gt; data_page_header_clear[p]) and // free page headers have no fields set&#x000a;    (all p: DirPageHeader | Free in p.typestate =&gt; dir_page_header_clear[p]) and &#x000a;    (all o: PMObj | orphan[o] =&gt; Free in o.typestate) and // all orphan objects are free&#x000a;    (all i: DirInode | some p: DirPageHeader | Free !in i.typestate =&gt; i in p.inode) and // all non-free dir inodes have at least one page header &#x000a;    (all i: DirInode | Free !in i.typestate =&gt; lte[#linked_dentries[i], 1]) and // each live directory is pointed to by at most one dentry&#x000a;    (all p: DirPageHeader | Root in p.inode &lt;=&gt; Root in p.parent_ino) and &#x000a;    (all d: Dentry | no d.rename_pointer) and &#x000a;    (all p: DirPageHeader, i: Inode | i in p.inode =&gt; i in DirInode) and &#x000a;    (all p: DataPageHeader, i: Inode | i in p.inode =&gt; i in FileInode) and &#x000a;    (all p: DirPageHeader, i: Inode | i in p.parent_ino =&gt; i in DirInode)&#x000a;}&#x000a;&#x000a;pred initial_link_count {&#x000a;    (all i: FileInode {&#x000a;        initialized[i] =&gt;&#x000a;            i.link_count = #i.linked_dentries&#x000a;        else &#x000a;            no i.link_count&#x000a;    }) and&#x000a;    (all i: DirInode {&#x000a;        initialized[i] =&gt;&#x000a;            i.link_count = add[2, #i.child_directories]&#x000a;        else &#x000a;            no i.link_count&#x000a;    })&#x000a;}&#x000a;&#x000a;// TODO: this definition will have to change for rename - we want to exclude &#x000a;// inodes that have been superseded by another inode in a rename operation&#x000a;pred live [o: PMObj] {&#x000a;    o in Root.*(Volatile.children) + &#x000a;        Root.*(Volatile.owns) +&#x000a;        Root.*(Volatile.owns.dentries) +&#x000a;        Root.*(Volatile.children.(Volatile.owns)) + &#x000a;        Root.*(Volatile.children.(Volatile.owns.dentries))&#x000a;}&#x000a;&#x000a;pred orphan [o: PMObj] {&#x000a;    !live[o]&#x000a;}&#x000a;&#x000a;// returns true if the PMObj is initialized&#x000a;pred initialized [o: PMObj] {&#x000a;&#x0009;o in Inode =&gt;&#x000a;        Free !in o.typestate and AllocStarted !in o.typestate&#x000a;&#x0009;else &#x000a;        Free !in o.typestate and Alloc !in o.typestate and AllocStarted !in o.typestate&#x000a;}&#x000a;&#x000a;pred inode_alloc_done [i: Inode] {&#x000a;    i in InodeSet and i in LcSet and i in MetadataSet&#x000a;}&#x000a;&#x000a;pred inode_clear [i: Inode] {&#x000a;    i !in InodeSet and i !in LcSet and i !in MetadataSet&#x000a;}&#x000a;&#x000a;pred inode_values_unchanged_except_ino {&#x000a;    unchanged[LcSet] and (all i: Inode | unchanged[i.link_count]) and unchanged[MetadataSet]&#x000a;}&#x000a;pred inode_values_unchanged_except_lc {&#x000a;    unchanged[InodeSet] and unchanged[MetadataSet]&#x000a;}&#x000a;pred inode_values_unchanged_except_metadata {&#x000a;    unchanged[LcSet] and (all i: Inode | unchanged[i.link_count]) and unchanged[InodeSet]&#x000a;}&#x000a;&#x000a;pred pointers_unchanged {&#x000a;    all d: Dentry | (unchanged[d.inode] and unchanged[d.rename_pointer])&#x000a;    all p: PageHeader | unchanged[p.inode]&#x000a;    all p: DirPageHeader | (unchanged[p.dentries] and unchanged[p.parent_ino])&#x000a;}&#x000a;&#x000a;pred inode_values_unchanged {&#x000a;    unchanged[InodeSet] and unchanged[LcSet] and unchanged[MetadataSet] and &#x000a;    (all i: Inode | unchanged[i.link_count])&#x000a;}&#x000a;&#x000a;pred dentry_alloc_done [d: Dentry] {&#x000a;    eq[d.name_qw_set, 2]&#x000a;}&#x000a;&#x000a;pred dentry_clear [d: Dentry] {&#x000a;    eq[d.name_qw_set, 0] and no d.inode // TODO: add rename pointer to this&#x000a;}&#x000a;&#x000a;pred data_page_header_alloc_done [p: DataPageHeader] {&#x000a;    p in TypeSet&#x000a;}&#x000a;&#x000a;pred dir_page_header_alloc_done [p: DirPageHeader] {&#x000a;    p in TypeSet and some p.parent_ino&#x000a;}&#x000a;&#x000a;pred data_page_header_clear [p: DataPageHeader] {&#x000a;    p !in TypeSet and no p.inode&#x000a;}&#x000a;&#x000a;pred dir_page_header_clear [p: DirPageHeader] {&#x000a;    p !in TypeSet and no p.inode and no p.parent_ino&#x000a;}"/>

<source filename="/home/hayley/fs-modeling/transitions.als" content="open defs&#x000a;&#x000a;// transitions&#x000a;// TODO: clean up frame conditions&#x000a;&#x000a;// effect: moves an inode from Free -&gt; AllocStarted&#x000a;pred start_alloc_inode [i: Inode] {&#x000a;    // guard&#x000a;    i in Clean and orphan[i] and Free in i.typestate&#x000a;&#x000a;    // frame conditions&#x000a;    pointers_unchanged&#x000a;    inode_values_unchanged&#x000a;    pm_states_unchanged&#x000a;    all o: PMObj - i | unchanged[o.typestate]&#x000a;&#x000a;    // effects&#x000a;    i.(typestate&apos;) = i.typestate + AllocStarted - Free&#x000a;}&#x000a;&#x000a;// effect: makes an inode dirty and sets its inode number&#x000a;pred set_inode_ino [i: Inode] {&#x000a;    // guard&#x000a;    AllocStarted in i.typestate and i !in InodeSet&#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged_except_ino&#x000a;    pointers_unchanged&#x000a;    op_states_unchanged&#x000a;&#x000a;    // effects&#x000a;    make_dirty[i]&#x000a;    InodeSet&apos; = InodeSet + i&#x000a;}&#x000a;&#x000a;// effect: makes a directory inode dirty and sets its link count&#x000a;pred set_dir_inode_link_count [i: DirInode] {&#x000a;    // guard&#x000a;    AllocStarted in i.typestate and i !in LcSet&#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged_except_lc&#x000a;    pointers_unchanged&#x000a;    op_states_unchanged&#x000a;    all i0: Inode - i | unchanged[i0.link_count]&#x000a;&#x000a;    // effects&#x000a;    make_dirty[i]&#x000a;    i.link_count&apos; = 2&#x000a;    // this automatically updates LcSet&#x000a;}&#x000a;&#x000a;// effect: makes a file inode dirty and sets its link count&#x000a;pred set_file_inode_link_count [i: FileInode] {&#x000a;    // guard &#x000a;    AllocStarted in i.typestate and i !in LcSet &#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged_except_lc&#x000a;    pointers_unchanged&#x000a;    op_states_unchanged&#x000a;    all i0: Inode - i | unchanged[i0.link_count]&#x000a;&#x000a;    // effects &#x000a;    make_dirty[i]&#x000a;    i.link_count&apos; = 1&#x000a;}&#x000a;&#x000a;// effect: makes an inode dirty and sets its metadata state&#x000a;pred set_inode_metadata [i: Inode] {&#x000a;    // guard &#x000a;    AllocStarted in i.typestate and i !in MetadataSet &#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged_except_metadata&#x000a;    pointers_unchanged&#x000a;    op_states_unchanged&#x000a;&#x000a;    // effects &#x000a;    make_dirty[i]&#x000a;    MetadataSet&apos; = MetadataSet + i&#x000a;}&#x000a;&#x000a;// effect: moves an inode from AllocStarted -&gt; Alloc&#x000a;pred finish_alloc_inode [i: Inode] {&#x000a;    // guard&#x000a;    AllocStarted in i.typestate and inode_alloc_done[i]&#x000a;&#x000a;    // frame conditions&#x000a;    pointers_unchanged &#x000a;    inode_values_unchanged&#x000a;    all o: PMObj - i | unchanged[o.typestate]&#x000a;    pm_states_unchanged&#x000a;&#x000a;    i.(typestate&apos;) = i.typestate + Alloc - AllocStarted&#x000a;}&#x000a;&#x000a;// file names can be at most 16 bytes - this is hard coded into this transition right now&#x000a;// this transition sets some bytes in the name by increasing the number of quadwords&#x000a;// that have been set in the name. the specific bytes that are set or clear does &#x000a;// not really matter for the purposes of the model&#x000a;// effect: makes a dentry dirty, moves it from Free -&gt; AllocStarted or AllocStarted -&gt; Alloc&#x000a;pred dentry_set_name_bytes [d: Dentry] {&#x000a;    // guard &#x000a;    (AllocStarted in d.typestate and eq[d.name_qw_set, 1]) or Free in d.typestate and &#x000a;    live[dentry_belongs_to[d]] // the page that the dentry belongs to must be live&#x000a;&#x000a;    // frame conditions&#x000a;    pointers_unchanged&#x000a;    inode_values_unchanged &#x000a;    all d0: Dentry - d | unchanged[d0.name_qw_set]&#x000a;    all o: PMObj - d | unchanged[o.typestate]&#x000a;&#x000a;    // effects &#x000a;    make_dirty[d]&#x000a;    Free in d.typestate =&gt; (&#x000a;        d.(typestate&apos;) = d.typestate + AllocStarted - Free&#x000a;    )&#x000a;    AllocStarted in d.typestate =&gt; (&#x000a;        d.(typestate&apos;) = d.typestate + Alloc - AllocStarted&#x000a;    )&#x000a;&#x000a;    d.(name_qw_set&apos;) = add[d.name_qw_set, 1]&#x000a;}&#x000a;&#x000a;// effect: makes a dentry dirty, moves that dentry from Alloc -&gt; Init,&#x000a;// moves the parent of that dentry from IncLink -&gt; Start,&#x000a;// moves another directory inode from Init -&gt; Complete&#x000a;pred set_dir_ino_in_dentry [i: DirInode, d: Dentry] {&#x000a;    let p = d.dentry_parent {&#x000a;        // guards&#x000a;        // TODO: how do we enforce the orphan[i] guard in the Rust code...&#x000a;        d in Clean and Alloc in d.typestate and i in Clean and Init in i.typestate&#x000a;        and orphan[i] and IncLink in p.typestate and p in Clean&#x000a;&#x000a;        // frame conditions&#x000a;        all d0: Dentry - d | unchanged[d0.inode] &#x000a;        all d0: Dentry | unchanged[d0.rename_pointer]&#x000a;        all p: PageHeader | unchanged[p.inode]&#x000a;        all p: DirPageHeader | (unchanged[p.dentries] and unchanged[p.parent_ino])&#x000a;        inode_values_unchanged&#x000a;        all o: PMObj - i - d - p | unchanged[o.typestate]&#x000a;&#x000a;        // effects&#x000a;        d.(inode&apos;) = i&#x000a;        // modifying d makes it dirty &#x000a;        Dirty&apos; = Dirty + d&#x000a;        Clean&apos; = Clean - d &#x000a;&#x000a;        p.(typestate&apos;) = p.typestate - IncLink //+ Start &#x000a;        i.(typestate&apos;) = i.typestate - Init + Complete &#x000a;        d.(typestate&apos;) = d.typestate - Alloc + Init &#x000a;    }&#x000a;}&#x000a;&#x000a;// effect: makes a dentry dirty, moves that dentry from Alloc -&gt; Init,&#x000a;// moves the inode from IncLink -&gt; Complete&#x000a;pred set_file_ino_in_dentry [i: FileInode, d: Dentry] {&#x000a;    // guards &#x000a;    d in Clean and Alloc in d.typestate and i in Clean and &#x000a;    (Alloc in i.typestate or IncLink in i.typestate)&#x000a;&#x000a;    // frame conditions&#x000a;    all d0: Dentry - d | unchanged[d0.inode]&#x000a;    all d0: Dentry | unchanged[d0.rename_pointer]&#x000a;    all p: PageHeader | unchanged[p.inode]&#x000a;    all p: DirPageHeader | (unchanged[p.dentries] and unchanged[p.parent_ino])&#x000a;    inode_values_unchanged&#x000a;    all o: PMObj - i - d | unchanged[o.typestate]&#x000a;&#x000a;    // effects&#x000a;    d.(inode&apos;) = i&#x000a;    // modifying d makes it dirty &#x000a;    Dirty&apos; = Dirty + d&#x000a;    Clean&apos; = Clean - d &#x000a;&#x000a;    i.(typestate&apos;) = i.typestate - IncLink - Alloc + Complete &#x000a;    d.(typestate&apos;) = d.typestate - Alloc + Init&#x000a;}&#x000a;&#x000a;// effect: moves an inode from Complete -&gt; Start, moves &#x000a;// a dentry from Init -&gt; Start&#x000a;pred complete_creat_and_link [i: Inode, d: Dentry] {&#x000a;    // guards&#x000a;    i in Clean and d in Clean and&#x000a;    Complete in i.typestate and Init in d.typestate&#x000a;&#x000a;    // frame conditions&#x000a;    pointers_unchanged&#x000a;    inode_values_unchanged&#x000a;    pm_states_unchanged&#x000a;    all o: PMObj - i - d | unchanged[o.typestate]&#x000a;&#x000a;    // effects&#x000a;    i.(typestate&apos;) = i.typestate - Complete //+ Start &#x000a;    d.(typestate&apos;) = d.typestate - Init //+ Start&#x000a;}&#x000a;&#x000a;// effect: moves a dir page header from Free -&gt; AllocStarted&#x000a;pred start_alloc_dir_page [p: DirPageHeader] {&#x000a;    // guards &#x000a;    p in Clean and Free in p.typestate&#x000a;&#x000a;    // frame conditions&#x000a;    pointers_unchanged&#x000a;    inode_values_unchanged&#x000a;    pm_states_unchanged&#x000a;    all o: PMObj - p | unchanged[o.typestate]&#x000a;&#x000a;    // effects&#x000a;    p.(typestate&apos;) = p.typestate - Free + AllocStarted&#x000a;}&#x000a;&#x000a;// effect: makes a dir page header dirty and sets its type&#x000a;pred set_page_header_type [p: PageHeader] {&#x000a;    // guards &#x000a;    AllocStarted in p.typestate and p !in TypeSet&#x000a;&#x000a;    // frame conditions&#x000a;    pointers_unchanged &#x000a;    inode_values_unchanged&#x000a;    op_states_unchanged &#x000a;&#x000a;    // effects&#x000a;    make_dirty[p]&#x000a;    TypeSet&apos; = TypeSet + p&#x000a;}&#x000a;&#x000a;// effect: makes a dir page header dirty and sets its parent&#x000a;pred set_dir_page_parent [p: DirPageHeader, parent: DirInode] {&#x000a;    // guards&#x000a;    AllocStarted in p.typestate and no p.parent_ino and live[parent]&#x000a;&#x000a;    // frame conditions&#x000a;    all d: Dentry | (unchanged[d.inode] and unchanged[d.rename_pointer])&#x000a;    all p0: PageHeader | unchanged[p0.inode]&#x000a;    all p0: DirPageHeader | unchanged[p0.dentries]&#x000a;    all p0: DirPageHeader - p | unchanged[p0.parent_ino]&#x000a;    inode_values_unchanged&#x000a;    op_states_unchanged&#x000a;&#x000a;    // effects&#x000a;    make_dirty[p]&#x000a;    p.parent_ino&apos; = p.parent_ino + parent&#x000a;}&#x000a;&#x000a;// effect: moves a dir page header from AllocStarted -&gt; Alloc&#x000a;pred finish_alloc_dir_page [p: DirPageHeader] {&#x000a;    // guards &#x000a;    AllocStarted in p.typestate and dir_page_header_alloc_done[p]&#x000a;&#x000a;    // frame conditions&#x000a;    pointers_unchanged&#x000a;    inode_values_unchanged&#x000a;    pm_states_unchanged&#x000a;    all o: PMObj - p | unchanged[o.typestate]&#x000a;&#x000a;    p.(typestate&apos;) = p.typestate - AllocStarted + Alloc&#x000a;}&#x000a;&#x000a;// effect: sets the backpointer (. dentry) in a dir page header,&#x000a;// makes the dir page header dirty, moves the inode it points to &#x000a;// from Alloc | Start -&gt; Init and and moves the dir page header&#x000a;// from Alloc -&gt; Init&#x000a;pred set_dir_page_backpointer [p: DirPageHeader, i: DirInode] {&#x000a;    // guards&#x000a;    Alloc in p.typestate and no p.inode and p in Clean and &#x000a;    initialized[i] and i in Clean&#x000a;    // (Start in i.typestate or Alloc in i.typestate) and i in Clean&#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged&#x000a;    all d: Dentry | (unchanged[d.inode] and unchanged[d.rename_pointer])&#x000a;    all p0: DirPageHeader | unchanged[p0.dentries]&#x000a;    all p0: PageHeader - p | (unchanged[p0.inode] and unchanged[p0.parent_ino])&#x000a;    unchanged[p.parent_ino]&#x000a;    all o: PMObj - p - i | unchanged[o.typestate]&#x000a;&#x000a;    // effects&#x000a;    make_dirty[p]&#x000a;    p.(inode&apos;) = p.inode + i // TODO: can we just set it to i?&#x000a;    i.(typestate&apos;) = i.typestate - Alloc + Init //- Start &#x000a;    p.(typestate&apos;) = p.typestate - Alloc + Init&#x000a;}&#x000a;&#x000a;// effect: sets the backpointer in a data page header, makes the &#x000a;// data page header dirty, moves the data page header from Alloc -&gt; Init&#x000a;pred set_data_page_backpointer [p: DataPageHeader, i: FileInode] {&#x000a;    // guards&#x000a;    Alloc in p.typestate and no p.inode and p in Clean and &#x000a;    initialized[i] and i in Clean&#x000a;    // (Start in i.typestate or Alloc in i.typestate) and i in Clean&#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged&#x000a;    all d: Dentry | (unchanged[d.inode] and unchanged[d.rename_pointer])&#x000a;    all p0: DirPageHeader | (unchanged[p0.dentries] and unchanged[p0.inode] and unchanged[p0.parent_ino])&#x000a;    all p0: PageHeader - p | unchanged[p0.inode]&#x000a;    all o: PMObj - p - i | unchanged[o.typestate]&#x000a;&#x000a;    // effects&#x000a;    make_dirty[p]&#x000a;    p.(inode&apos;) = p.inode + i // TODO: can we just set it to i?&#x000a;    i.(typestate&apos;) = i.typestate - Alloc + Init //- Start&#x000a;    p.(typestate&apos;) = p.typestate - Alloc + Init&#x000a;}&#x000a;&#x000a;// effect: increments an inode&apos;s link count, makes the inode dirty, and &#x000a;// moves it from Start -&gt; IncLink&#x000a;pred inc_link_count [i: Inode] {&#x000a;    // guards &#x000a;    // Start in i.typestate&#x000a;    initialized[i]&#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged_except_lc&#x000a;    pointers_unchanged &#x000a;    all i0: Inode - i | unchanged[i0.link_count]&#x000a;    all o: PMObj - i | unchanged[o.typestate]&#x000a;&#x000a;    // effects&#x000a;    make_dirty[i]&#x000a;    i.(link_count&apos;) = add[i.link_count, 1]&#x000a;    i.(typestate&apos;) = i.typestate + IncLink //- Start&#x000a;}&#x000a;&#x000a;// ideally we could pass in the parent as well, but Alloy has trouble visualizing&#x000a;// the corresponding 5-ary auxiliary function that actually represents the&#x000a;// transition. getting the parent from Volatile lets us avoid that issue&#x000a;// TODO: ^^ that probably isn&apos;t true anymore&#x000a;// effect: moves a dir page header and dentry from Init -&gt; Start, moves &#x000a;// the new inode and its new parent from Complete -&gt; Start&#x000a;pred complete_mkdir [d: Dentry, i: DirInode, p: DirPageHeader] {&#x000a;    // guards &#x000a;    d in Clean and i in Clean and p in Clean and &#x000a;    Init in d.typestate and Complete in i.typestate and Init in p.typestate&#x000a;&#x000a;    // frame conditions&#x000a;    pointers_unchanged &#x000a;    inode_values_unchanged&#x000a;    pm_states_unchanged&#x000a;    all o: PMObj - d - i - p | unchanged[o.typestate]&#x000a;&#x000a;    // effects&#x000a;    let i_parent = i.(Volatile.parent) {&#x000a;        all o: PMObj - d - i - p | unchanged[o.typestate]&#x000a;        d.(typestate&apos;) = d.typestate - Init //+ Start &#x000a;        i.(typestate&apos;) = i.typestate - Complete //+ Start &#x000a;        i_parent.(typestate&apos;) = i_parent.typestate - Complete //+ Start &#x000a;        p.(typestate&apos;) = p.typestate - Init //+ Start&#x000a;    }&#x000a;}&#x000a;&#x000a;pred set_rename_pointer [src, dst: Dentry] {&#x000a;    // guards&#x000a;    // dst may be a newly-allocated dentry without an inode number &#x000a;    // or an existing dentry pointing to a different inode&#x000a;    // Start in src.typestate and (Alloc in dst.typestate or Start in dst.typestate) &#x000a;    initialized[src] and (Alloc in dst.typestate or initialized[dst])&#x000a;    and dst in Clean and src.inode != dst.inode&#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged&#x000a;    all d: Dentry | unchanged[d.inode]&#x000a;    all d: Dentry - dst | unchanged[d.rename_pointer]&#x000a;    all p: PageHeader | unchanged[p.inode]&#x000a;    all p: DirPageHeader | (unchanged[p.dentries] and unchanged[p.parent_ino])&#x000a;    all o: PMObj - src - dst | unchanged[o.typestate]&#x000a;&#x000a;    // effects&#x000a;    make_dirty[dst]&#x000a;    dst.(rename_pointer&apos;) = src&#x000a;    src.(typestate&apos;) = src.typestate + Renaming //- Start &#x000a;    dst.(typestate&apos;) = dst.typestate - Alloc + SetRenamePointer //- Start&#x000a;}&#x000a;&#x000a;// TODO: should probably rename this transition, since it doesn&apos;t really have anything to do with &#x000a;// the rename pointer&#x000a;pred init_rename_pointer [src, dst: Dentry] {&#x000a;    // guards &#x000a;    Renaming in src.typestate and SetRenamePointer in dst.typestate and dst in Clean&#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged&#x000a;    all d: Dentry | unchanged[d.rename_pointer]&#x000a;    all p: PageHeader | unchanged[p.inode]&#x000a;    all p: DirPageHeader | (unchanged[p.dentries] and unchanged[p.parent_ino])&#x000a;    all d: Dentry - dst | unchanged[d.inode]&#x000a;    all o: PMObj - src - dst | unchanged[o.typestate]&#x000a;&#x000a;    // effects&#x000a;    make_dirty[dst]&#x000a;    dst.(inode&apos;) = src.inode&#x000a;    src.(typestate&apos;) = src.typestate - Renaming + Renamed &#x000a;    dst.(typestate&apos;) = dst.typestate - SetRenamePointer + InitRenamePointer&#x000a;}&#x000a;&#x000a;// this transition is only used for dentry deallocation during rename, since it&#x000a;// has specific requirements that do not apply in unlink/rmdir&#x000a;pred clear_ino_rename [src, dst: Dentry] {&#x000a;    // guards &#x000a;    Renamed in src.typestate and src in Clean and InitRenamePointer in dst.typestate and dst in Clean&#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged&#x000a;    all d: Dentry | unchanged[d.rename_pointer]&#x000a;    all d: Dentry - src | unchanged[d.inode]&#x000a;    all p: PageHeader | unchanged[p.inode]&#x000a;    all p: DirPageHeader | (unchanged[p.dentries] and unchanged[p.parent_ino])&#x000a;    all o: PMObj - src | unchanged[o.typestate]&#x000a;    &#x000a;    // effects&#x000a;    make_dirty[src]&#x000a;    no src.(inode&apos;)&#x000a;    src.(typestate&apos;) = src.typestate - Renamed + ClearIno&#x000a;}&#x000a;&#x000a;pred clear_rename_pointer [src, dst: Dentry] {&#x000a;    // guards&#x000a;    ClearIno in src.typestate and src in Clean and InitRenamePointer in dst.typestate and dst in Clean&#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged&#x000a;    all d: Dentry | unchanged[d.inode]&#x000a;    all d: Dentry - dst | unchanged[d.rename_pointer]&#x000a;    all p: PageHeader | unchanged[p.inode]&#x000a;    all p: DirPageHeader | (unchanged[p.dentries] and unchanged[p.parent_ino])&#x000a;    all o: PMObj - dst | unchanged[o.typestate]&#x000a;&#x000a;    // effects&#x000a;    make_dirty[dst]&#x000a;    no dst.(rename_pointer&apos;)&#x000a;    dst.(typestate&apos;) = dst.typestate - InitRenamePointer + ClearRenamePointer&#x000a;}&#x000a;&#x000a;pred start_dealloc_renamed_dentry [src, dst: Dentry] {&#x000a;    // guards &#x000a;    ClearIno in src.typestate and src in Clean and ClearRenamePointer in dst.typestate and dst in Clean&#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged&#x000a;    pointers_unchanged&#x000a;    pm_states_unchanged&#x000a;    all o: PMObj - src | unchanged[o.typestate]&#x000a;&#x000a;    // effects&#x000a;    src.(typestate&apos;) = src.typestate - ClearIno + DeallocStart&#x000a;}&#x000a;&#x000a;pred dentry_clear_name_bytes [d: Dentry] {&#x000a;    // guards &#x000a;    DeallocStart in d.typestate and gt[d.name_qw_set, 0]&#x000a;    &#x000a;    // frame conditions&#x000a;    inode_values_unchanged&#x000a;    pointers_unchanged&#x000a;    op_states_unchanged&#x000a;    all d0: Dentry - d | unchanged[d0.name_qw_set]&#x000a;    op_states_unchanged&#x000a;&#x000a;    // effects&#x000a;    make_dirty[d]&#x000a;    d.(name_qw_set&apos;) = sub[d.name_qw_set, 1]&#x000a;}&#x000a;&#x000a;pred dealloc_rename_pointer [d: Dentry] {&#x000a;    // guards&#x000a;    DeallocStart in d.typestate and some d.rename_pointer&#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged&#x000a;    all d0: Dentry | unchanged[d0.inode]&#x000a;    all d0: Dentry - d | unchanged[d0.rename_pointer]&#x000a;    all p: PageHeader | unchanged[p.inode]&#x000a;    all p: DirPageHeader | (unchanged[p.dentries] and unchanged[p.parent_ino])&#x000a;    op_states_unchanged&#x000a;&#x000a;    // effects&#x000a;    make_dirty[d]&#x000a;    no d.(rename_pointer&apos;)&#x000a;}&#x000a;&#x000a;pred finish_dealloc_dentry [d: Dentry] {&#x000a;    // guards&#x000a;    DeallocStart in d.typestate and d in Clean and eq[d.name_qw_set, 0] and no d.inode and no d.rename_pointer&#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged&#x000a;    pointers_unchanged&#x000a;    pm_states_unchanged&#x000a;    all o: PMObj - d | unchanged[o.typestate]&#x000a;&#x000a;    // effects&#x000a;    no d.(name_qw_set&apos;)&#x000a;    d.(typestate&apos;) = d.typestate - DeallocStart + Dealloc&#x000a;}&#x000a;&#x000a;// TODO: need to account for case where deletion/rename of dst could cause &#x000a;// reappearance of old src after a crash. need to model crashing first though.&#x000a;pred complete_rename [src, dst: Dentry] {&#x000a;    // guards &#x000a;    Dealloc in src.typestate and src in Clean and ClearRenamePointer in dst.typestate and dst in Clean&#x000a;&#x000a;    // frame conditions&#x000a;    inode_values_unchanged &#x000a;    pointers_unchanged&#x000a;    pm_states_unchanged &#x000a;    all o: PMObj - src - dst | unchanged[o.typestate]&#x000a;    &#x000a;    // effects&#x000a;    src.(typestate&apos;) = src.typestate - Dealloc + Free &#x000a;    dst.(typestate&apos;) = dst.typestate - ClearRenamePointer //+ Start&#x000a;}&#x000a;                                                                                                                                                                                                                                                                                                                         &#x000a;// effect: moves one PMObj from Dirty to InFlight&#x000a;pred clwb [o: PMObj] {&#x000a;    // guard&#x000a;    o in Dirty&#x000a;&#x000a;    // frame conditions&#x000a;    pointers_unchanged&#x000a;    inode_values_unchanged&#x000a;    unchanged[Clean]&#x000a;    op_states_unchanged&#x000a;&#x000a;    // effects&#x000a;    InFlight&apos; = InFlight + o&#x000a;    Dirty&apos; = Dirty - o&#x000a;}&#x000a;&#x000a;// effect: moves all InFlight PMObjs to Clean&#x000a;pred fence {&#x000a;    // guard&#x000a;    // not technically required for correctness, but it doesn&apos;t make senes&#x000a;    // to call fence when there are no in-flight writes&#x000a;    some InFlight&#x000a;&#x000a;    // frame conditions&#x000a;    pointers_unchanged&#x000a;    inode_values_unchanged&#x000a;    unchanged[Dirty]&#x000a;    op_states_unchanged&#x000a;&#x000a;    // effects&#x000a;    // fence acts on ALL in-flight objects&#x000a;    Clean&apos; = Clean + InFlight&#x000a;    no InFlight&apos;&#x000a;}&#x000a;&#x000a;// skip essentially lets us terminate a trace at any point rather than&#x000a;// having to set things up for a loop back to a previous state&#x000a;// I don&apos;t think this will break anything because we are not interested&#x000a;// in using `eventually`/proving liveness, but be careful&#x000a;// TODO: is there a better way to do this?&#x000a;// effect: none&#x000a;pred skip {&#x000a;    // no guard&#x000a;&#x000a;    // frame conditions&#x000a;    pointers_unchanged&#x000a;    inode_values_unchanged&#x000a;    unchanged[TypeSet]&#x000a;    pm_states_unchanged&#x000a;    op_states_unchanged&#x000a;    all d: Dentry | unchanged[d.name_qw_set]&#x000a;    &#x000a;    // no effects&#x000a;}&#x000a;&#x000a;// // simulates a crash occurring&#x000a;// // TODO: fix this up and add this back in as an option for a transition&#x000a;// pred crash {&#x000a;//     // no guard - a crash can happen at any time&#x000a;&#x000a;//     // frame conditions&#x000a;&#x000a;//     // rather than specifying what values may nondeterministically be lost&#x000a;//     // in a crash for objects in the middle of allocation, we will assume&#x000a;//     // that anything written prior to the crash is saved&#x000a;//     inode_values_unchanged&#x000a;//     // pointers in clean objects don&apos;t change&#x000a;//     all p: DirPageHeader | unchanged[p.dentries]&#x000a;    &#x000a;//     // TODO: is it necessary to model these explicitly, or can we just assume that &#x000a;//     // dirty/in-flight writes get persisted, and if they haven&apos;t been done before&#x000a;//     // the crash it&apos;s equivalent to losing them dirty?&#x000a;//     // nondeterministically decrement link count for dirty/in-flight IncLink&#x000a;//     all i: Inode { &#x000a;//         (i in IncLink and (i in Dirty or i in InFlight)) =&gt;&#x000a;//             eq[i.(link_count&apos;), sub[i.link_count, 1]]&#x000a;//             // (unchanged[i.link_count] or eq[i.(link_count&apos;), sub[i.link_count, 1]])&#x000a;//     }&#x000a;//     all p: PageHeader { &#x000a;//         (p in Init and (p in Dirty or p in InFlight)) =&gt; &#x000a;//             no p.(inode&apos;)&#x000a;//             // (unchanged[p.inode] or no p.(inode&apos;))&#x000a;//         else &#x000a;//             unchanged[p.inode]&#x000a;//     }&#x000a;//     all d: Dentry {&#x000a;//         (d in Init and (d in Dirty or d in InFlight)) =&gt;&#x000a;//             (no d.(inode&apos;) and unchanged[d.inode] and unchanged[d.rename_pointer])&#x000a;//             // ((unchanged[d.inode] or no d.(inode&apos;)) and unchanged[d.inode] and unchanged[d.rename_pointer])&#x000a;//         else {&#x000a;//             ((d in AllocStarted or d in Alloc) and (d in Dirty or d in InFlight)) =&gt;&#x000a;//                 (eq[d.(name_qw_set&apos;), 0] and unchanged[d.inode] and unchanged[d.rename_pointer])&#x000a;//             else &#x000a;//                 unchanged[d.inode] and unchanged[d.rename_pointer]&#x000a;//                 // TODO: might want a case to nondeterminisically drop the rename pointer&#x000a;//         }&#x000a;//     }&#x000a;//     all p: DirPageHeader {&#x000a;//         (p in AllocStarted and (p in Dirty or p in InFlight)) =&gt;&#x000a;//             no p.(parent_ino&apos;)&#x000a;//             // (unchanged[p.parent_ino] or no p.(parent_ino&apos;))&#x000a;//         else &#x000a;//             unchanged[p.parent_ino]&#x000a;//     }&#x000a;&#x000a;//     // all objects become clean&#x000a;//     all o: PMObj | o in Clean&apos;&#x000a;&#x000a;//     // free orphaned objects stay free&#x000a;//     // all other objects go to Start&#x000a;//     all o: Inode + PageHeader {&#x000a;//         o in Free =&gt; &#x000a;//             o in Free&apos;&#x000a;//         else &#x000a;//             o in Start&apos;&#x000a;//     }&#x000a;//     all d: Dentry {&#x000a;//         eq[d.(name_qw_set&apos;), 0] =&gt; d in Free&apos;&#x000a;//         else d in Start&apos;&#x000a;//     }&#x000a;// }&#x000a;&#x000a;&#x000a;"/>

<source filename="/home/hayley/fs-modeling/model2.als" content="open defs&#x000a;open transitions&#x000a;open util/integer&#x000a;&#x000a;// TODO: continue converting the auxiliary functions into the new versions with lower overhead and updating&#x000a;// them in the visualizer. Then continue with rename testing.&#x000a;&#x000a;// auxiliary functions for visualization&#x000a;// these won&apos;t show up if they are moved to a different file so they have to live here&#x000a;fun Live : set PMObj {&#x000a;    { o: PMObj | live[o] }&#x000a;}&#x000a;// orphan objects are all objects NOT reachable from the root&#x000a;fun Orphan : set PMObj {&#x000a;    { o: PMObj | orphan[o] }&#x000a;}&#x000a;&#x000a;fun StartState : set PMObj {&#x000a;    { o: PMObj | Start in o.typestate }&#x000a;}&#x000a;&#x000a;fun FreeState : set PMObj {&#x000a;    { o: PMObj | Free in o.typestate }&#x000a;}&#x000a;&#x000a;fun AllocStartedState : set PMObj {&#x000a;    { o: PMObj | AllocStarted in o.typestate }&#x000a;}&#x000a;&#x000a;fun AllocState : set PMObj {&#x000a;    { o: PMObj | Alloc in o.typestate }&#x000a;}&#x000a;&#x000a;fun InitState : set PMObj {&#x000a;    { o: PMObj | Init in o.typestate }&#x000a;}&#x000a;&#x000a;fun CompleteState : set PMObj {&#x000a;    { o: PMObj | Complete in o.typestate }&#x000a;}&#x000a;&#x000a;fun start_alloc_file_inode : Inode {&#x000a;    { i: FileInode | start_alloc_inode[i] }&#x000a;}&#x000a;&#x000a;fun start_alloc_dir_inode : Inode {&#x000a;    { i: DirInode | start_alloc_inode[i] }&#x000a;}&#x000a;&#x000a;fun set_inode_ino : Inode {&#x000a;    { i: Inode | set_inode_ino[i] }&#x000a;}&#x000a;&#x000a;fun set_dir_inode_link_count : Inode {&#x000a;    { i: DirInode | set_dir_inode_link_count[i] }&#x000a;}&#x000a;&#x000a;fun set_file_inode_link_count : Inode {&#x000a;    { i: FileInode | set_file_inode_link_count[i] }&#x000a;}&#x000a;&#x000a;fun set_inode_metadata : Inode {&#x000a;    { i: Inode | set_inode_metadata[i] }&#x000a;}&#x000a;&#x000a;fun finish_alloc_inode : Inode {&#x000a;    { i: Inode | finish_alloc_inode[i] }&#x000a;}&#x000a;&#x000a;fun dentry_set_name_bytes : Dentry {&#x000a;    { d: Dentry | dentry_set_name_bytes[d] }&#x000a;}&#x000a;&#x000a;&#x000a;fun set_dir_ino_in_dentry_i : DirInode {&#x000a;    { i: DirInode | some d: Dentry | set_dir_ino_in_dentry[i, d] }&#x000a;}&#x000a;&#x000a;fun set_dir_ino_in_dentry_d : Dentry {&#x000a;    { d: Dentry | some i: DirInode | set_dir_ino_in_dentry[i, d] }&#x000a;}&#x000a;&#x000a;&#x000a;fun set_file_ino_in_dentry_i : FileInode {&#x000a;    { i: FileInode | some d: Dentry | set_file_ino_in_dentry[i, d] }&#x000a;}&#x000a;&#x000a;fun set_file_ino_in_dentry_d : Dentry {&#x000a;    { d: Dentry | some i: FileInode | set_file_ino_in_dentry[i, d] }&#x000a;}&#x000a;&#x000a;fun complete_create_and_link_i : Inode {&#x000a;    { i: Inode | some d: Dentry | complete_creat_and_link[i, d] }&#x000a;}&#x000a;&#x000a;fun complete_create_and_link_d : Dentry {&#x000a;    { d: Dentry | some i: Inode | complete_creat_and_link[i, d] }&#x000a;}&#x000a;&#x000a;fun start_alloc_dir_page : DirPageHeader {&#x000a;    { p: DirPageHeader | start_alloc_dir_page[p] }&#x000a;}&#x000a;&#x000a;fun set_page_header_type : PageHeader {&#x000a;    { p: PageHeader | set_page_header_type[p] }&#x000a;}&#x000a;&#x000a;fun set_dir_page_parent_p : DirPageHeader {&#x000a;    { p: DirPageHeader | some parent: DirInode | set_dir_page_parent[p, parent] }&#x000a;}&#x000a;&#x000a;fun set_dir_page_parent_i : DirInode {&#x000a;    { parent: DirInode | some p: DirPageHeader | set_dir_page_parent[p, parent] }&#x000a;}&#x000a;&#x000a;fun finish_alloc_dir_page : DirPageHeader {&#x000a;    { p: DirPageHeader | finish_alloc_dir_page[p] }&#x000a;}&#x000a;&#x000a;fun set_dir_page_backpointer_p : DirPageHeader {&#x000a;    { p: DirPageHeader | some i: DirInode | set_dir_page_backpointer[p, i] }&#x000a;}&#x000a;&#x000a;fun set_dir_page_backpointer_i : DirInode {&#x000a;    { i: DirInode | some p: DirPageHeader | set_dir_page_backpointer[p, i] }&#x000a;}&#x000a;&#x000a;fun set_data_page_backpointer_p : DataPageHeader {&#x000a;    { p: DataPageHeader | some i: FileInode | set_data_page_backpointer[p, i] }&#x000a;}&#x000a;&#x000a;fun set_data_page_backpointer_i : FileInode {&#x000a;    { i: FileInode | some p: DataPageHeader | set_data_page_backpointer[p, i] }&#x000a;}&#x000a;&#x000a;fun inc_link_count : Inode {&#x000a;    { i: Inode | inc_link_count[i] }&#x000a;}&#x000a;&#x000a;fun complete_mkdir_d : Dentry {&#x000a;    { d: Dentry | some i: DirInode, p: DirPageHeader | complete_mkdir[d, i, p] }&#x000a;}&#x000a;&#x000a;fun complete_mkdir_i : DirInode {&#x000a;    { i: DirInode | some d: Dentry, p: DirPageHeader | complete_mkdir[d, i, p] }&#x000a;}&#x000a;&#x000a;fun complete_mkdir_p: DirPageHeader {&#x000a;    { p: DirPageHeader | some d: Dentry, i: DirInode | complete_mkdir[d, i, p] }&#x000a;}&#x000a;&#x000a;fun set_rename_ptr_src : Dentry {&#x000a;    { src: Dentry | some dst: Dentry | set_rename_pointer[src, dst] }&#x000a;}&#x000a;&#x000a;fun set_rename_ptr_dst : Dentry {&#x000a;    { dst: Dentry | some src: Dentry | set_rename_pointer[src, dst] }&#x000a;}&#x000a;&#x000a;fun init_rename_pointer_src : Dentry {&#x000a;    { src: Dentry | some dst: Dentry | init_rename_pointer[src, dst] }&#x000a;}&#x000a;&#x000a;fun init_rename_pointer_dst : Dentry {&#x000a;    { dst: Dentry | some src: Dentry | init_rename_pointer[src, dst] }&#x000a;}&#x000a;&#x000a;fun clear_ino_rename_src : Dentry {&#x000a;    { src: Dentry | some dst: Dentry | clear_ino_rename[src, dst] }&#x000a;}&#x000a;&#x000a;fun clear_ino_rename_dst : Dentry {&#x000a;    { dst: Dentry | some src: Dentry | clear_ino_rename[src, dst] }&#x000a;}&#x000a;&#x000a;fun clear_rename_pointer_src : Dentry {&#x000a;    { src: Dentry | some dst: Dentry | clear_rename_pointer[src, dst] }&#x000a;}&#x000a;&#x000a;fun clear_rename_pointer_dst : Dentry {&#x000a;    { dst: Dentry | some src: Dentry | clear_rename_pointer[src, dst] }&#x000a;}&#x000a;&#x000a;fun start_dealloc_renamed_dentry_src : Dentry {&#x000a;    { src: Dentry | some dst: Dentry | start_dealloc_renamed_dentry[src, dst] }&#x000a;}&#x000a;&#x000a;fun start_dealloc_renamed_dentry_dst : Dentry {&#x000a;    { dst: Dentry | some src: Dentry | start_dealloc_renamed_dentry[src, dst] }&#x000a;}&#x000a;&#x000a;fun dentry_clear_name_bytes : Dentry {&#x000a;    { d: Dentry | dentry_clear_name_bytes[d] }&#x000a;}&#x000a;&#x000a;fun dealloc_rename_pointer : Dentry {&#x000a;    { d: Dentry | dealloc_rename_pointer[d] }&#x000a;}&#x000a;&#x000a;fun finish_dealloc_dentry : Dentry {&#x000a;    { d: Dentry | finish_dealloc_dentry[d] }&#x000a;}&#x000a;&#x000a;fun complete_rename_src : Dentry {&#x000a;    { src: Dentry | some dst: Dentry | complete_rename[src, dst] }&#x000a;}&#x000a;&#x000a;fun complete_rename_dst : Dentry {&#x000a;    { dst: Dentry | some src: Dentry | complete_rename[src, dst] }&#x000a;}&#x000a;&#x000a;fun clwb : PMObj {&#x000a;    { o: PMObj | clwb[o] }&#x000a;}&#x000a;&#x000a;fun fence : PMObj {&#x000a;    { o: PMObj | fence and o in InFlight and o in Clean&apos;}&#x000a;}&#x000a;&#x000a;fun skip : PMObj {&#x000a;    { o: PMObj | skip }&#x000a;}&#x000a;&#x000a;&#x000a;fact transition {&#x000a;    always (&#x000a;        (some i: Inode | start_alloc_inode[i] or set_inode_ino[i] or set_inode_metadata[i] or &#x000a;                         finish_alloc_inode[i] or inc_link_count[i]) or &#x000a;        (some i: DirInode | set_dir_inode_link_count[i]) or&#x000a;        (some i: FileInode | set_file_inode_link_count[i]) or&#x000a;        (some d: Dentry | dentry_set_name_bytes[d] or dentry_clear_name_bytes[d] or dealloc_rename_pointer[d] or&#x000a;                        finish_dealloc_dentry[d]) or&#x000a;        (some i: DirInode, d: Dentry | set_dir_ino_in_dentry[i, d]) or&#x000a;        (some i: FileInode, d: Dentry | set_file_ino_in_dentry[i ,d]) or &#x000a;        (some i: Inode, d: Dentry | complete_creat_and_link[i,d]) or&#x000a;        (some p: DirPageHeader | start_alloc_dir_page[p] or set_page_header_type[p] or finish_alloc_dir_page[p]) or&#x000a;        (some p: DirPageHeader, i: DirInode | set_dir_page_parent[p, i] or set_dir_page_backpointer[p, i]) or&#x000a;        (some p: DataPageHeader, i: FileInode | set_data_page_backpointer[p, i]) or&#x000a;        (some d: Dentry, i: DirInode, p: DirPageHeader | complete_mkdir[d, i, p]) or&#x000a;        (some src, dst: Dentry | set_rename_pointer[src, dst] or init_rename_pointer[src, dst] or &#x000a;                                clear_ino_rename[src, dst] or clear_rename_pointer[src, dst] or&#x000a;                                start_dealloc_renamed_dentry[src, dst] or complete_rename[src, dst]) or&#x000a;        (some o: PMObj | clwb[o]) or&#x000a;        fence or&#x000a;        skip&#x000a;    )&#x000a;}&#x000a;&#x000a;// some constraints to reduce frame condition verbosity&#x000a;// these ensure that certain sets can only be modified in a step that involves certain operations&#x000a;// e.g., an inode can only be added or removed from InodeSet by an operation that updates &#x000a;// an inode&apos;s ino number.&#x000a;// TODO: we may have some redundant frame condition constraints in transitions; see if we can &#x000a;// take any of them out without breaking anything&#x000a;// see https://alloytools.discourse.group/t/how-to-reduce-temporal-update-boilerplate-for-state-rich-models/219/2&#x000a;fact { always (InodeSet&apos; != InodeSet =&gt; (some i: Inode | set_inode_ino[i])) }&#x000a;fact { always (LcSet&apos; != LcSet =&gt; (some i: Inode | set_dir_inode_link_count[i] or set_file_inode_link_count[i])) }&#x000a;fact { always (MetadataSet&apos; != MetadataSet =&gt; (some i: Inode | set_inode_metadata[i])) }&#x000a;fact { always (all d: Dentry | (d.(name_qw_set&apos;) != d.name_qw_set) =&gt; &#x000a;    (some d: Dentry | dentry_set_name_bytes[d] or dentry_clear_name_bytes[d] or finish_dealloc_dentry[d])) }&#x000a;fact { always (TypeSet&apos; != TypeSet =&gt; (some p: PageHeader | set_page_header_type[p])) }&#x000a;fact { always (all i: Inode | (i.(link_count&apos;) != i.link_count) =&gt; &#x000a;    (some i: Inode | set_dir_inode_link_count[i] or set_file_inode_link_count[i] or inc_link_count[i])) }&#x000a;&#x000a;// checks and assertions&#x000a;run create_file { &#x000a;    some i: FileInode | orphan[i] and eventually live[i]&#x000a;} for 1 Volatile, 5 PMObj, 1..25 steps&#x000a;&#x000a;// objects in the free state cannot have any other typestate&#x000a;free_state: check {&#x000a;    all o: PMObj | Free in o.typestate =&gt; eq[#o.typestate, 1]&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;// TODO: rerun&#x000a;pred mkdir {&#x000a;    some i: DirInode | Free in i.typestate and eventually (live[i])&#x000a;}&#x000a;&#x000a;run mkdir {&#x000a;    mkdir&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;// check that the new dir in mkdir actually gets a DirPageHeader&#x000a;// a live directory inode not having a DirPageHeader pointing to it&#x000a;// is unsafe because that directory does not have . or .. dentries&#x000a;// technically we could reconstruct them at mount from the inode&apos;s &#x000a;// parent, but it is simpler to do it during regular execution&#x000a;new_dir_page: check {&#x000a;    mkdir =&gt; (some i: DirInode, p: DirPageHeader | Free in p.typestate and Free in i.typestate and eventually (i in p.inode))&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;dir_inode_init: check {&#x000a;    all i: DirInode | some p: DirPageHeader {&#x000a;        initialized[i] =&gt; i in p.inode&#x000a;    }&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;mkdir_link_count: check {&#x000a;    some new_i, parent_i: DirInode {&#x000a;        mkdir =&gt;&#x000a;        eventually (&#x000a;            parent_i.(link_count&apos;) = add[parent_i.link_count, 1] and // at some point p&apos;s link count increases&#x000a;            eventually ( // and at some later point&#x000a;                parent_i.(Volatile.(children&apos;)) = parent_i.(Volatile.children) + new_i // p obtains new as a child&#x000a;            )&#x000a;        )&#x000a;    }&#x000a;} for 1 Volatile, 5 PMObj, 1..25 steps&#x000a;&#x000a;file_link_count: check {&#x000a;    always (all i: FileInode | initialized[i] =&gt; gte[i.link_count, #i.linked_dentries])&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;dir_link_count: check {&#x000a;    always (all i: DirInode | initialized[i] =&gt; gte[i.link_count, add[1, #i.child_directories]])&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;root_link_count: check {&#x000a;    gte[Root.link_count, add[2, #Root.child_directories]]&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;// check that we cannot create links to directory inodes &#x000a;no_dir_links: check {&#x000a;    always (all i: DirInode | lte[#i.linked_dentries, 1])&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;// TODO: rerun&#x000a;// check that links can be created and model is not over constrainted&#x000a;run link {&#x000a;    some d: Dentry, i: FileInode {&#x000a;        Free in d.typestate and initialized[i] and eventually (i in d.inode)&#x000a;    }&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;run two_parent {&#x000a;    some d0, d1: DirInode, i: Inode {&#x000a;        d0 != d1 and i in d0.(Volatile.owns).dentries.inode and &#x000a;        i in d1.(Volatile.owns).dentries.inode&#x000a;    }&#x000a;} for 1 Volatile, 10 PMObj, 1..25 steps&#x000a;&#x000a;page_header_type: check {&#x000a;    (all p: DirPageHeader | p.inode in DirInode) and &#x000a;    (all p: DataPageHeader | p.inode in FileInode)&#x000a;} for 1 Volatile, 10 PMObj, 1..25 steps&#x000a;&#x000a;// sanity check to make sure an obviously false assertion fails&#x000a;all_inode: check {&#x000a;    always (all o: PMObj {&#x000a;        o in Inode&#x000a;    })&#x000a;} for 1 Volatile, 5 PMObj, 1..25 steps&#x000a;&#x000a;run rename {&#x000a;    some src, dst: Dentry | eventually (ClearRenamePointer in dst.typestate and Dealloc in src.typestate&#x000a;                         and eventually (no dst.typestate and Free in src.typestate)) &#x000a;} for 1 Volatile, 5 PMObj, 1..25 steps&#x000a;&#x000a;// dentries cannot point to uninit inodes&#x000a;point_to_uninit0: check {&#x000a;    always (all d: Dentry, i: Inode | !initialized[i] =&gt; i !in d.inode)&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;// page headers cannot point to uninit inodes&#x000a;point_to_uninit1: check {&#x000a;    always (all p: PageHeader, i: Inode | !initialized[i] =&gt; i !in p.inode)&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;point_to_uninit_dir_page_parent: check {&#x000a;    always (all p: DirPageHeader, i: DirInode | !initialized[i] =&gt; i !in p.parent_ino)&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;// uninit inodes cannot have parents&#x000a;// sanity check - should be implied directly by the definition of parent&#x000a;// children is the inverse of parent so we don&apos;t need to check it&#x000a;point_to_uninit2: check {&#x000a;    always (all v: Volatile, i: Inode, dir: DirInode | !initialized[i] =&gt; dir !in i.(v.parent))&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;// uninit pages cannot be owned by inodes&#x000a;// sanity check - should be implied directly by the definition of owns&#x000a;point_to_uninit3: check {&#x000a;    always (all v: Volatile, i: Inode, p: PageHeader | !initialized[p] =&gt; p !in i.(v.owns))&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;point_to_uninit4: check {&#x000a;    always (all d0, d1: Dentry | d1 in d0.rename_pointer =&gt; Free !in d1.typestate)&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;// if an inode is live, it should be fully allocated&#x000a;live_inode_allocated: check {&#x000a;    always (all i: Inode | i in Live =&gt; inode_alloc_done[i] )&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;// initialized dentries (i.e., not free or in AllocStarted) should always have a full name&#x000a;init_dentry_full_name: check {&#x000a;    always (all d:Dentry | initialized[d] =&gt; eq[d.name_qw_set, 2])&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;// test frame conditions&#x000a;&#x000a;pred i_change_j_unchanged [i, j: Inode, s: InodeValues] {&#x000a;    // if i and j are distinct and i moved in or out of s, then j should stay where it is&#x000a;    ((i != j) and ((i !in s and i in s&apos;) or (i in s and i !in s&apos;))) =&gt; (&#x000a;        j in s =&gt; &#x000a;            j in s&apos;&#x000a;        else &#x000a;            j !in s&apos;&#x000a;    )&#x000a;}&#x000a;// for two distinct inodes i and j, if one of i&apos;s values changes in one step, then none of j&apos;s values&#x000a;// should change in that step&#x000a;inode_fc_single_ino: check {&#x000a;    always ( &#x000a;        (all i, j: Inode | i != j =&gt; i_change_j_unchanged[i, j, InodeSet]) and &#x000a;        (all i, j: Inode | i != j =&gt; i_change_j_unchanged[i, j, LcSet]) and &#x000a;        (all i, j: Inode | i != j =&gt; i_change_j_unchanged[i, j, MetadataSet])&#x000a;    )&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;// check that only one set changes at a time&#x000a;inode_fc_single_field: check {&#x000a;    always (&#x000a;        (InodeSet != InodeSet&apos; =&gt; inode_values_unchanged_except_ino) and &#x000a;        (LcSet != LcSet&apos; =&gt; inode_values_unchanged_except_lc) and &#x000a;        (MetadataSet != MetadataSet&apos; =&gt; inode_values_unchanged_except_metadata)&#x000a;    )&#x000a;    &#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;dir_header_ino: check {&#x000a;    always (all p: DirPageHeader, i: Inode | i in p.inode =&gt; i in DirInode)&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;dir_header_parent_ino: check {&#x000a;    always (all p: DirPageHeader, i: Inode | i in p.parent_ino =&gt; i in DirInode)&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;file_header_ino: check {&#x000a;    always (all p: DataPageHeader, i: Inode | i in p.inode =&gt; i in FileInode) &#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;&#x000a;// checks for soft updates rules 2 and 3: &#x000a;// 2. never re-use a resource before nullifying all previous pointers to it&#x000a;// 3. never reset the old pointer to a live resource before the new pointer has been set&#x000a;&#x000a;no_reuse_ptr: check {&#x000a;    always (all o: PMObj {&#x000a;        Free in o.typestate =&gt; (&#x000a;            // no other structures point to the free object&#x000a;            (all d: Dentry | o !in d.inode and o !in d.rename_pointer) and &#x000a;            (all p: DirPageHeader | o !in p.parent_ino) and &#x000a;            (all p: PageHeader | o !in p.inode) and &#x000a;            // and the free object has no outgoing pointers forming connections to other objects&#x000a;            (o in Dentry =&gt; no o.(Dentry &lt;: inode) and no o.rename_pointer) and&#x000a;            (o in PageHeader =&gt; no o.(PageHeader &lt;: inode)) and &#x000a;            (o in DirPageHeader =&gt; no o.parent_ino)&#x000a;        )&#x000a;    })&#x000a;} for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;&#x000a;&#x000a;// FIXME: we don&apos;t really have enough infrastructure for this to be straightforward to check correctly&#x000a;// // TODO: update this when there are other traces that can legally cause an object to become orphaned&#x000a;// no_orphan: check {&#x000a;//     // all o: PMObj | o in Live =&gt; always (o in Live)&#x000a;//     // the only way o can be in Orphan in the next step is if the dentry that owns it&#x000a;//     // is about to be the destination in a rename&#x000a;//     // OR IF IT IS ONLY REACHABLE THROUGH SUCH AN INODE&#x000a;//     always (all o: PMObj {&#x000a;//             o in Orphan and before (o in Live) =&gt; (some d: Dentry | before (o in d.inode) and d in InitRenamePointer)&#x000a;//         }&#x000a;//     )&#x000a;// } for 1 Volatile, 7 PMObj, 1..25 steps&#x000a;"/>

</alloy>
